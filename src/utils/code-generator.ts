import type { ScriptNode, NodeConnection } from '../types/visual-scripting';

interface ThreadFunction {
  name: string;
  nodeId: string;
  outputPortId: string;
}

interface CodeGenContext {
  nodes: ScriptNode[];
  connections: NodeConnection[];
  nodeMap: Map<string, ScriptNode>;
  visitedNodes: Set<string>;
  indentLevel: number;
  variables: Map<string, string>;
  varCounter: number;
  threadFunctions: ThreadFunction[];
  pendingLines: string[]; // Lines generated by data nodes that need to be prepended
  portals: Map<string, string>; // Portal name -> variable name
}

function getInputConnections(ctx: CodeGenContext, nodeId: string, portId: string): NodeConnection[] {
  return ctx.connections.filter(c => c.to.nodeId === nodeId && c.to.portId === portId);
}

function getOutputConnections(ctx: CodeGenContext, nodeId: string, portId: string): NodeConnection[] {
  return ctx.connections.filter(c => c.from.nodeId === nodeId && c.from.portId === portId);
}

function indent(ctx: CodeGenContext): string {
  return '    '.repeat(ctx.indentLevel);
}

function getVarName(ctx: CodeGenContext, prefix: string = 'v'): string {
  return `${prefix}${ctx.varCounter++}`;
}

// Map visual scripting dataTypes to Squirrel types
function getSquirrelType(dataType: string | undefined): string {
  switch (dataType) {
    case 'entity':
    case 'player':
    case 'weapon':
      return 'entity';
    case 'boolean':
      return 'bool';
    case 'number':
    case 'int':
      return 'int';
    case 'float':
      return 'float';
    case 'string':
      return 'string';
    case 'vector':
      return 'vector';
    case 'array':
      return 'array';
    case 'table':
      return 'table';
    default:
      return 'var';
  }
}

function formatLiteral(value: unknown): string {
  if (value === null || value === undefined) return 'null';
  if (typeof value === 'string') return `"${value}"`;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  if (Array.isArray(value)) {
    return `[${value.map(formatLiteral).join(', ')}]`;
  }
  return String(value);
}

function getInputValue(ctx: CodeGenContext, node: ScriptNode, portId: string): string {
  const inputConns = getInputConnections(ctx, node.id, portId);

  if (inputConns.length > 0) {
    const conn = inputConns[0];
    const varKey = `${conn.from.nodeId}:${conn.from.portId}`;
    const varVal = ctx.variables.get(varKey);
    if (varVal) return varVal;

    // Try to generate the source node first if it's a data node
    const sourceNode = ctx.nodeMap.get(conn.from.nodeId);
    if (sourceNode && !ctx.visitedNodes.has(sourceNode.id)) {
      const generatedCode = generateNodeCode(ctx, sourceNode);
      // Add the generated code to pending lines so it gets output before the node that uses it
      if (generatedCode && generatedCode.trim()) {
        ctx.pendingLines.push(generatedCode);
      }
      const newVal = ctx.variables.get(varKey);
      if (newVal) return newVal;
    }
    return 'null';
  }

  // Check node data for default value
  const port = node.inputs.find(p => p.id === portId);
  if (port) {
    // Try exact match with data keys
    for (const [key, val] of Object.entries(node.data)) {
      const keyLower = key.toLowerCase();
      const labelLower = port.label.toLowerCase().replace(/\s+/g, '');
      if (keyLower === labelLower || labelLower.includes(keyLower)) {
        if ((port.dataType === 'asset' || port.dataType === 'function') && typeof val === 'string') {
          return val;
        }
        return formatLiteral(val);
      }
    }
  }

  return 'null';
}

function generateNodeCode(ctx: CodeGenContext, node: ScriptNode): string {
  const lines: string[] = [];
  const ind = indent(ctx);

  // Helper to follow exec output
  const followExec = (portId: string) => {
    const conns = getOutputConnections(ctx, node.id, portId);
    for (const conn of conns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) lines.push(code);
    }
  };

  switch (node.type) {
    // ==================== CORE FLOW ====================
    case 'sequence':
    case 'exec-sequence': {
      const execOuts = node.outputs.filter(p => p.type === 'exec');
      for (const out of execOuts) {
        followExec(out.id);
      }
      break;
    }

    case 'branch': {
      const condition = getInputValue(ctx, node, 'input_1');
      // Flush any pending lines before the if statement (e.g., variable declarations from condition evaluation)
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}if (${condition})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // True
      ctx.indentLevel--;
      lines.push(`${ind}}`);

      const falseConns = getOutputConnections(ctx, node.id, 'output_1');
      if (falseConns.length > 0) {
        lines.push(`${ind}else`);
        lines.push(`${ind}{`);
        ctx.indentLevel++;
        followExec('output_1'); // False
        ctx.indentLevel--;
        lines.push(`${ind}}`);
      }
      break;
    }

    case 'delay':
    case 'wait': {
      const duration = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}wait ${duration}`);
      followExec('output_0');
      break;
    }

    case 'loop-for': {
      const start = getInputValue(ctx, node, 'input_1');
      const end = getInputValue(ctx, node, 'input_2');
      const step = getInputValue(ctx, node, 'input_3');
      const indexVar = getVarName(ctx, 'i');
      ctx.variables.set(`${node.id}:output_1`, indexVar);

      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}for (local ${indexVar} = ${start}; ${indexVar} < ${end}; ${indexVar} += ${step})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_2'); // Done
      break;
    }

    case 'loop-foreach': {
      const array = getInputValue(ctx, node, 'input_1');
      const elemVar = getVarName(ctx, 'elem');
      const indexVar = getVarName(ctx, 'idx');
      ctx.variables.set(`${node.id}:output_1`, elemVar);
      ctx.variables.set(`${node.id}:output_2`, indexVar);

      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}foreach (${indexVar}, ${elemVar} in ${array})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_3'); // Done
      break;
    }

    case 'loop-while': {
      const condition = getInputValue(ctx, node, 'input_1');
      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}while (${condition})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_1'); // Done
      break;
    }

    case 'custom-code': {
      const code = typeof node.data?.code === 'string' ? node.data.code : '// Your code here';
      // Split code into lines and add proper indentation
      const codeLines = code.split('\n');
      for (const codeLine of codeLines) {
        lines.push(`${ind}${codeLine}`);
      }
      followExec('output_0');
      break;
    }

    case 'call-function': {
      const funcName = getInputValue(ctx, node, 'input_1');
      const returnType = typeof node.data?.returnType === 'string' ? node.data.returnType : 'none';
      const argCount = typeof node.data?.argCount === 'number' ? node.data.argCount : 1;
      const threaded = typeof node.data?.threaded === 'boolean' ? node.data.threaded : false;
      
      // Build arguments list - collect all connected args
      const args: string[] = [];
      for (let i = 0; i < argCount; i++) {
        const arg = getInputValue(ctx, node, `input_${i + 2}`);
        if (arg && arg !== 'null') {
          args.push(arg);
        }
      }
      const argStr = args.join(', ');
      
      // Add thread prefix if threaded
      const threadPrefix = threaded ? 'thread ' : '';
      
      if (returnType !== 'none' && !threaded) {
        // Can't capture return value from threaded call
        const resultVar = getVarName(ctx, 'result');
        ctx.variables.set(`${node.id}:output_1`, resultVar);
        lines.push(`${ind}${returnType} ${resultVar} = ${funcName}(${argStr})`);
      } else {
        lines.push(`${ind}${threadPrefix}${funcName}(${argStr})`);
      }
      followExec('output_0');
      break;
    }

    // Server callback event nodes - when exec input is connected, generate the AddCallback registration
    case 'on-entities-did-load': {
      const funcName = node.data?.functionName || 'OnEntitiesDidLoad';
      lines.push(`${ind}AddCallback_EntitiesDidLoad( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-client-connected': {
      const funcName = node.data?.functionName || 'OnClientConnected';
      lines.push(`${ind}AddCallback_OnClientConnected( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-client-disconnected': {
      const funcName = node.data?.functionName || 'OnClientDisconnected';
      lines.push(`${ind}AddCallback_OnClientDisconnected( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-player-killed': {
      const funcName = node.data?.functionName || 'OnPlayerKilled';
      lines.push(`${ind}AddCallback_OnPlayerKilled( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-player-respawned': {
      const funcName = node.data?.functionName || 'OnPlayerRespawned';
      lines.push(`${ind}AddCallback_OnPlayerRespawned( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-npc-killed': {
      const funcName = node.data?.functionName || 'OnNPCKilled';
      lines.push(`${ind}AddCallback_OnNPCKilled( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-client-connecting': {
      const funcName = node.data?.functionName || 'OnClientConnecting';
      lines.push(`${ind}AddCallback_OnClientConnecting( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-entity-changed-team': {
      const funcName = node.data?.functionName || 'OnEntityChangedTeam';
      lines.push(`${ind}AddCallback_EntityChangedTeam( "player", ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-assist': {
      const funcName = node.data?.functionName || 'OnPlayerAssist';
      lines.push(`${ind}AddCallback_OnPlayerAssist( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-inventory-changed': {
      const funcName = node.data?.functionName || 'OnPlayerInventoryChanged';
      lines.push(`${ind}AddCallback_OnPlayerInventoryChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-weapon-attack': {
      const funcName = node.data?.functionName || 'OnWeaponAttack';
      lines.push(`${ind}AddCallback_OnWeaponAttack( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-death-box-spawned': {
      const funcName = node.data?.functionName || 'OnDeathBoxSpawned';
      lines.push(`${ind}AddCallback_OnDeathBoxSpawned( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-game-state-enter': {
      const funcName = node.data?.functionName || 'OnGameStatePostEnter';
      lines.push(`${ind}AddCallback_GameStatePostEnter( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-weapon-activated': {
      const funcName = node.data?.functionName || 'OnPlayerWeaponActivated';
      lines.push(`${ind}AddCallback_OnPlayerWeaponActivated( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-used-offhand': {
      const funcName = node.data?.functionName || 'OnPlayerUsedOffhandWeapon';
      lines.push(`${ind}AddCallback_OnPlayerUsedOffhandWeapon( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-leave-match': {
      const funcName = node.data?.functionName || 'OnLeaveMatch';
      lines.push(`${ind}AddCallback_OnLeaveMatch( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-use-button-pressed': {
      const funcName = node.data?.functionName || 'OnUseButtonPressed';
      lines.push(`${ind}AddCallback_OnUseButtonPressed( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-use-button-released': {
      const funcName = node.data?.functionName || 'OnUseButtonReleased';
      lines.push(`${ind}AddCallback_OnUseButtonReleased( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-class-changed': {
      const funcName = node.data?.functionName || 'OnPlayerClassChanged';
      lines.push(`${ind}AddCallback_PlayerClassChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-vehicle-launch': {
      const funcName = node.data?.functionName || 'OnVehicleLaunch';
      lines.push(`${ind}AddCallback_OnVehicleLaunch( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-vehicle-collide': {
      const funcName = node.data?.functionName || 'OnVehicleCollide';
      lines.push(`${ind}AddCallback_OnVehicleCollide( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-changed-team': {
      const funcName = node.data?.functionName || 'OnPlayerChangedTeam';
      lines.push(`${ind}AddCallback_OnPlayerChangedTeam( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-zoom-in': {
      const funcName = node.data?.functionName || 'OnPlayerZoomIn';
      lines.push(`${ind}AddCallback_OnPlayerZoomIn( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-zoom-out': {
      const funcName = node.data?.functionName || 'OnPlayerZoomOut';
      lines.push(`${ind}AddCallback_OnPlayerZoomOut( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-passive-changed': {
      const funcName = node.data?.functionName || 'OnPassiveChanged';
      lines.push(`${ind}AddCallback_OnPassiveChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-ping-created': {
      const funcName = node.data?.functionName || 'OnPingCreatedByAnyPlayer';
      lines.push(`${ind}AddCallback_OnPingCreatedByAnyPlayer( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-match-state-changed': {
      const funcName = node.data?.functionName || 'OnPlayerMatchStateChanged';
      lines.push(`${ind}AddCallback_OnPlayerMatchStateChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-deathfield-stage-changed': {
      const funcName = node.data?.functionName || 'OnSurvivalDeathFieldStageChanged';
      lines.push(`${ind}AddCallback_OnSurvivalDeathFieldStageChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-bleedout-started': {
      const funcName = node.data?.functionName || 'OnBleedoutStarted';
      lines.push(`${ind}AddCallback_OnBleedoutStarted( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-bleedout-ended': {
      const funcName = node.data?.functionName || 'OnBleedoutEnded';
      lines.push(`${ind}AddCallback_OnBleedoutEnded( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-life-state-changed': {
      const funcName = node.data?.functionName || 'OnPlayerLifeStateChanged';
      lines.push(`${ind}AddCallback_OnPlayerLifeStateChanged( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-you-respawned': {
      const funcName = node.data?.functionName || 'OnYouRespawned';
      lines.push(`${ind}AddCallback_OnYouRespawned( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-you-died': {
      const funcName = node.data?.functionName || 'OnYouDied';
      lines.push(`${ind}AddCallback_OnYouDied( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-scored': {
      const funcName = node.data?.functionName || 'OnPlayerScored';
      lines.push(`${ind}AddCallback_OnPlayerScored( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-lootbin-opened': {
      const funcName = node.data?.functionName || 'OnLootbinOpened';
      lines.push(`${ind}Survival_AddCallback_OnLootbinOpened( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-add-weapon-mod': {
      const funcName = node.data?.functionName || 'OnPlayerAddWeaponMod';
      lines.push(`${ind}AddCallback_OnPlayerAddWeaponMod( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-player-remove-weapon-mod': {
      const funcName = node.data?.functionName || 'OnPlayerRemoveWeaponMod';
      lines.push(`${ind}AddCallback_OnPlayerRemoveWeaponMod( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-grappled': {
      const funcName = node.data?.functionName || 'OnGrappled';
      lines.push(`${ind}AddCallback_OnGrappled( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'on-grapple-detached': {
      const funcName = node.data?.functionName || 'OnGrappleDetached';
      lines.push(`${ind}AddCallback_OnGrappleDetached( ${funcName} )`);
      followExec('output_0');
      break;
    }

    case 'return': {
      const returnValue = getInputValue(ctx, node, 'input_1');
      if (returnValue && returnValue !== 'null') {
        lines.push(`${ind}return ${returnValue}`);
      } else {
        lines.push(`${ind}return`);
      }
      break;
    }

    case 'reroute': {
      // Reroute nodes pass through both execution and data - they're just for visual organization
      // Pass through data value from input to output
      const inputValue = getInputValue(ctx, node, 'input_0');
      ctx.variables.set(`${node.id}:output_0`, inputValue);
      // Also follow exec if this is an exec reroute
      followExec('output_0');
      break;
    }

    case 'set-portal': {
      const portalName = node.data?.portalName || 'MyPortal';
      const value = getInputValue(ctx, node, 'input_1');
      
      // Store the original variable name as an alias - no new variable created
      // This allows the portal to auto-detect the type and avoid intermediate variables
      ctx.portals.set(portalName, value);
      followExec('output_0');
      break;
    }

    case 'get-portal': {
      const portalName = node.data?.portalName || 'MyPortal';
      
      if (ctx.portals.has(portalName)) {
        // Return the original variable name directly - auto-detects type
        ctx.variables.set(`${node.id}:output_0`, ctx.portals.get(portalName)!);
      } else {
        // Portal not set yet, use null as fallback
        ctx.variables.set(`${node.id}:output_0`, 'null /* Portal "' + portalName + '" not set */');
      }
      break;
    }

    // ==================== GAMEMODES ====================
    case 'gamemode-create': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}GameMode_Create(${gamemode})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-name': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const name = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetName(${gamemode}, ${name})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-desc': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const desc = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetDesc(${gamemode}, ${desc})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-score-limits': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const scoreLimit = getInputValue(ctx, node, 'input_2');
      const roundScoreLimit = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}GameMode_SetDefaultScoreLimits(${gamemode}, ${scoreLimit}, ${roundScoreLimit})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-time-limits': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const timeLimit = getInputValue(ctx, node, 'input_2');
      const roundTimeLimit = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}GameMode_SetDefaultTimeLimits(${gamemode}, ${timeLimit}, ${roundTimeLimit})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-scoreboard-column': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const title = getInputValue(ctx, node, 'input_2');
      const scoreType = getInputValue(ctx, node, 'input_3');
      const numDigits = getInputValue(ctx, node, 'input_4');
      lines.push(`${ind}GameMode_AddScoreboardColumnData(${gamemode}, ${title}, ${scoreType}, ${numDigits})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-shared-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddSharedInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-server-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddServerInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-client-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddClientInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-evac': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const enabled = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetEvacEnabled(${gamemode}, ${enabled})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-register-spawn-func': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      const isPilot = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}RegisterGamemodeSpawnFunc(${gamemode}, ${func}, ${isPilot})`);
      followExec('output_0');
      break;
    }

    case 'get-game-state': {
      const resultVar = getVarName(ctx, 'gameState');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = GetGameState()`);
      break;
    }

    case 'set-game-state': {
      const state = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}SetGameState(${state})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-register': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const modName = getInputValue(ctx, node, 'input_2');
      const displayName = getInputValue(ctx, node, 'input_3');
      const description = getInputValue(ctx, node, 'input_4');
      const customScoreboard = getInputValue(ctx, node, 'input_5');
      const sharedInitFn = getInputValue(ctx, node, 'input_6');
      const serverInitFn = getInputValue(ctx, node, 'input_7');
      const clientInitFn = getInputValue(ctx, node, 'input_8');
      lines.push(`${ind}RegisterGamemode(${gamemode}, ${modName}, ${displayName}, ${description}, ${customScoreboard}, ${sharedInitFn}, ${serverInitFn}, ${clientInitFn})`);
      followExec('output_0');
      break;
    }

    // ==================== DAMAGE ====================
    case 'entity-take-damage': {
      const entity = getInputValue(ctx, node, 'input_1');
      const attacker = getInputValue(ctx, node, 'input_2');
      const inflictor = getInputValue(ctx, node, 'input_3');
      const damage = getInputValue(ctx, node, 'input_4');
      const damageType = getInputValue(ctx, node, 'input_5');
      lines.push(`${ind}${entity}.TakeDamage(${damage}, ${attacker}, ${inflictor}, { damageType = ${damageType} })`);
      followExec('output_0');
      break;
    }

    case 'radius-damage': {
      const origin = getInputValue(ctx, node, 'input_1');
      const attacker = getInputValue(ctx, node, 'input_2');
      const inflictor = getInputValue(ctx, node, 'input_3');
      const damage = getInputValue(ctx, node, 'input_4');
      const radius = getInputValue(ctx, node, 'input_5');
      lines.push(`${ind}RadiusDamage(${origin}, ${attacker}, ${inflictor}, ${damage}, ${radius})`);
      followExec('output_0');
      break;
    }

    // ==================== ENTITY ====================
    case 'get-origin': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'origin');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetOrigin()`);
      break;
    }

    case 'set-origin': {
      const entity = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetOrigin(${origin})`);
      followExec('output_0');
      break;
    }

    case 'get-velocity': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'velocity');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetVelocity()`);
      break;
    }

    case 'set-velocity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const velocity = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetVelocity(${velocity})`);
      followExec('output_0');
      break;
    }

    case 'get-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'health');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetHealth()`);
      break;
    }

    case 'get-max-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'maxHealth');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetMaxHealth()`);
      break;
    }

    case 'get-shield-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'shield');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetShieldHealth()`);
      break;
    }

    case 'get-team': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'team');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetTeam()`);
      break;
    }

    case 'get-player-name': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'playerName');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${player}.GetPlayerName()`);
      break;
    }

    case 'get-owner': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'owner');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${entity}.GetOwner()`);
      break;
    }

    case 'get-parent': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'parent');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${entity}.GetParent()`);
      break;
    }

    case 'get-class-name': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'className');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${entity}.GetClassName()`);
      break;
    }

    case 'get-ent-index': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'entIndex');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetEntIndex()`);
      break;
    }

    case 'get-script-name': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'scriptName');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${entity}.GetScriptName()`);
      break;
    }

    case 'get-view-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'viewVec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetViewVector()`);
      break;
    }

    case 'get-angles': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'angles');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetAngles()`);
      break;
    }

    case 'get-forward-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'forward');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetForwardVector()`);
      break;
    }

    case 'get-right-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'right');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetRightVector()`);
      break;
    }

    case 'get-up-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'up');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetUpVector()`);
      break;
    }

    case 'get-eye-position': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'eyePos');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.EyePosition()`);
      break;
    }

    case 'get-eye-angles': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'eyeAngles');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.EyeAngles()`);
      break;
    }

    case 'get-weapon-class-name': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'weaponClass');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${weapon}.GetWeaponClassName()`);
      break;
    }

    case 'set-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const health = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetHealth(${health})`);
      followExec('output_0');
      break;
    }

    case 'set-max-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const maxHealth = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetMaxHealth(${maxHealth})`);
      followExec('output_0');
      break;
    }

    case 'set-shield-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const shield = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetShieldHealth(${shield})`);
      followExec('output_0');
      break;
    }

    case 'set-team': {
      const entity = getInputValue(ctx, node, 'input_1');
      const team = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}SetTeam(${entity}, ${team})`);
      followExec('output_0');
      break;
    }

    case 'set-owner': {
      const entity = getInputValue(ctx, node, 'input_1');
      const owner = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetOwner(${owner})`);
      followExec('output_0');
      break;
    }

    case 'set-parent': {
      const entity = getInputValue(ctx, node, 'input_1');
      const parent = getInputValue(ctx, node, 'input_2');
      const attachment = getInputValue(ctx, node, 'input_3');
      if (attachment && attachment !== '""' && attachment !== 'null') {
        lines.push(`${ind}${entity}.SetParent(${parent}, ${attachment})`);
      } else {
        lines.push(`${ind}${entity}.SetParent(${parent})`);
      }
      followExec('output_0');
      break;
    }

    case 'clear-parent': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.ClearParent()`);
      followExec('output_0');
      break;
    }

    case 'set-angles': {
      const entity = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetAngles(${angles})`);
      followExec('output_0');
      break;
    }

    case 'set-script-name': {
      const entity = getInputValue(ctx, node, 'input_1');
      const scriptName = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetScriptName(${scriptName})`);
      followExec('output_0');
      break;
    }

    case 'is-valid': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isValid');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsValid(${entity})`);
      break;
    }

    case 'is-alive': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isAlive');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsAlive(${entity})`);
      break;
    }

    case 'is-player': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isPlayer');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsPlayer()`);
      break;
    }

    case 'is-npc': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isNPC');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsNPC()`);
      break;
    }

    case 'is-titan': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isTitan');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsTitan()`);
      break;
    }

    case 'is-pilot': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isPilot');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsPilot(${entity})`);
      break;
    }

    case 'kill-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.Kill()`);
      followExec('output_0');
      break;
    }

    case 'freeze': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.Freeze()`);
      followExec('output_0');
      break;
    }

    case 'unfreeze': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.Unfreeze()`);
      followExec('output_0');
      break;
    }

    case 'look-at': {
      const entity = getInputValue(ctx, node, 'input_1');
      const target = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.LookAt(${target})`);
      followExec('output_0');
      break;
    }

    case 'get-weapon-owner': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'owner');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${weapon}.GetWeaponOwner()`);
      break;
    }

    case 'register-mod-weapon': {
      const className = getInputValue(ctx, node, 'input_1');
      const name = getInputValue(ctx, node, 'input_2');
      const hudIcon = getInputValue(ctx, node, 'input_3');
      const weaponType = getInputValue(ctx, node, 'input_4');
      const pickupSound1p = getInputValue(ctx, node, 'input_5');
      const pickupSound3p = getInputValue(ctx, node, 'input_6');
      const tier = getInputValue(ctx, node, 'input_7');
      const baseMods = getInputValue(ctx, node, 'input_8');
      const supportedAttachments = getInputValue(ctx, node, 'input_9');
      const lowWeaponChance = getInputValue(ctx, node, 'input_10');
      const medWeaponChance = getInputValue(ctx, node, 'input_11');
      const highWeaponChance = getInputValue(ctx, node, 'input_12');
      const registerInLoot = getInputValue(ctx, node, 'input_13');

      const dataVar = getVarName(ctx, 'weaponData');
      lines.push(`${ind}CustomWeaponData ${dataVar}`);
      lines.push(`${ind}${dataVar}.className = ${className}`);
      lines.push(`${ind}${dataVar}.name = ${name}`);
      lines.push(`${ind}${dataVar}.hudIcon = ${hudIcon}`);
      lines.push(`${ind}${dataVar}.weaponType = ${weaponType}`);
      lines.push(`${ind}${dataVar}.pickupSound1p = ${pickupSound1p}`);
      lines.push(`${ind}${dataVar}.pickupSound3p = ${pickupSound3p}`);
      lines.push(`${ind}${dataVar}.tier = ${tier}`);
      lines.push(`${ind}${dataVar}.baseMods = ${baseMods}`);
      lines.push(`${ind}${dataVar}.supportedAttachments = ${supportedAttachments}`);
      lines.push(`${ind}${dataVar}.lowWeaponChance = ${lowWeaponChance}`);
      lines.push(`${ind}${dataVar}.medWeaponChance = ${medWeaponChance}`);
      lines.push(`${ind}${dataVar}.highWeaponChance = ${highWeaponChance}`);
      lines.push(`${ind}RegisterModWeapon(${dataVar}, ${registerInLoot})`);
      followExec('output_0');
      break;
    }

    // ==================== ENTITY STRUCT PROPERTIES ====================
    // Context-aware nodes that work in both SERVER and CLIENT contexts
    // player.p.* (ServerPlayerStruct / ClientPlayerStruct)
    case 'player-get-property': {
      const player = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'isSkydiving';
      const resultVar = getVarName(ctx, `player_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${player}.p.${property}`);
      break;
    }

    case 'player-set-property': {
      const player = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'isAdmin';
      lines.push(`${ind}${player}.p.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // entity.e.* (ServerEntityStruct / ClientEntityStruct)
    case 'entity-get-property': {
      const entity = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'spawnTime';
      const resultVar = getVarName(ctx, `ent_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${entity}.e.${property}`);
      break;
    }

    case 'entity-set-property': {
      const entity = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'canBeMeleed';
      lines.push(`${ind}${entity}.e.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // npc.ai.* (ServerAIStruct) - Server only
    case 'npc-get-property': {
      const npc = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'killCount';
      const resultVar = getVarName(ctx, `ai_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${npc}.ai.${property}`);
      break;
    }

    case 'npc-set-property': {
      const npc = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'buddhaMode';
      lines.push(`${ind}${npc}.ai.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // weapon.w.* (ServerWeaponStruct / ClientWeaponStruct)
    case 'weapon-get-struct-property': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'lastFireTime';
      const resultVar = getVarName(ctx, `wpn_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${weapon}.w.${property}`);
      break;
    }

    case 'weapon-set-struct-property': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'wasCharged';
      lines.push(`${ind}${weapon}.w.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // projectile.proj.* (ServerProjectileStruct / ClientProjectileStruct)
    case 'projectile-get-property': {
      const projectile = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'damageScale';
      const resultVar = getVarName(ctx, `proj_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${projectile}.proj.${property}`);
      break;
    }

    case 'projectile-set-property': {
      const projectile = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'damageScale';
      lines.push(`${ind}${projectile}.proj.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // soul.soul.* (ServerTitanSoulStruct / ClientTitanSoulStruct)
    case 'soul-get-property': {
      const soul = getInputValue(ctx, node, 'input_0');
      const property = node.data?.property || 'upgradeCount';
      const resultVar = getVarName(ctx, `soul_${property}`);
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${soul}.soul.${property}`);
      break;
    }

    case 'soul-set-property': {
      const soul = getInputValue(ctx, node, 'input_0');
      const value = getInputValue(ctx, node, 'input_1');
      const property = node.data?.property || 'regensHealth';
      lines.push(`${ind}${soul}.soul.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    // ==================== WEAPONS ====================
    case 'get-active-weapon': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${player}.GetActiveWeapon()`);
      break;
    }

    case 'give-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weaponClass = getInputValue(ctx, node, 'input_2');
      const mods = getInputValue(ctx, node, 'input_3');
      const slot = node.data?.slot || 'WEAPON_INVENTORY_SLOT_PRIMARY_0';
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      if (mods && mods !== 'null' && mods !== '[]') {
        lines.push(`${ind}entity ${resultVar} = ${player}.GiveWeapon(${weaponClass}, ${slot}, ${mods})`);
      } else {
        lines.push(`${ind}entity ${resultVar} = ${player}.GiveWeapon(${weaponClass}, ${slot}, [])`);
      }
      followExec('output_0');
      break;
    }

    case 'take-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weaponClass = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${player}.TakeWeapon(${weaponClass})`);
      followExec('output_0');
      break;
    }

    case 'take-all-weapons': {
      const player = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${player}.TakeAllWeapons()`);
      followExec('output_0');
      break;
    }

    case 'switch-to-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weapon = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${player}.SetActiveWeapon(${weapon})`);
      followExec('output_0');
      break;
    }

    case 'fire-weapon-bullet': {
      const weapon = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${weapon}.FireWeaponBullet()`);
      followExec('output_0');
      break;
    }

    // ==================== AUDIO ====================
    case 'emit-sound-on-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const sound = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}EmitSoundOnEntity(${entity}, ${sound})`);
      followExec('output_0');
      break;
    }

    // ==================== PARTICLES ====================
    case 'start-particle-on-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const effect = getInputValue(ctx, node, 'input_2');
      const attachment = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'fxHandle');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}int ${resultVar} = StartParticleEffectOnEntity(${entity}, GetParticleSystemIndex(${effect}), FX_PATTACH_POINT_FOLLOW, ${attachment})`);
      followExec('output_0');
      break;
    }

    // ==================== STRING ====================
    case 'string-concat': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'string-format': {
      const formatStr = getInputValue(ctx, node, 'input_0');
      const arg1 = getInputValue(ctx, node, 'input_1');
      const arg2 = getInputValue(ctx, node, 'input_2');
      const arg3 = getInputValue(ctx, node, 'input_3');
      const arg4 = getInputValue(ctx, node, 'input_4');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      
      // Build args list, only include non-null args
      const args = [arg1, arg2, arg3, arg4].filter(a => a && a !== 'null');
      if (args.length > 0) {
        lines.push(`${ind}string ${resultVar} = format(${formatStr}, ${args.join(', ')})`);
      } else {
        lines.push(`${ind}string ${resultVar} = ${formatStr}`);
      }
      break;
    }

    case 'to-string': {
      const value = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = string(${value})`);
      break;
    }

    // get-player-name case is handled earlier in the switch

    case 'string-builder': {
      const inputCount = typeof node.data?.inputCount === 'number' ? node.data.inputCount : node.inputs.length;
      const parts: string[] = [];
      for (let i = 0; i < inputCount; i++) {
        const part = getInputValue(ctx, node, `input_${i}`);
        if (part && part !== 'null') {
          parts.push(part);
        }
      }
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      if (parts.length === 0) {
        lines.push(`${ind}string ${resultVar} = ""`);
      } else if (parts.length === 1) {
        lines.push(`${ind}string ${resultVar} = string(${parts[0]})`);
      } else {
        // Wrap each part in string() and concatenate
        const stringParts = parts.map(p => `${p}`);
        lines.push(`${ind}string ${resultVar} = ${stringParts.join(' + ')}`);
      }
      break;
    }

    case 'string-length': {
      const str = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'length');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${str}.len()`);
      break;
    }

    case 'string-substring': {
      const str = getInputValue(ctx, node, 'input_0');
      const start = getInputValue(ctx, node, 'input_1');
      const end = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${str}.slice(${start}, ${end})`);
      break;
    }

    case 'string-split': {
      const str = getInputValue(ctx, node, 'input_0');
      const delimiter = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'array');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array ${resultVar} = split(${str}, ${delimiter})`);
      break;
    }

    case 'string-replace': {
      const str = getInputValue(ctx, node, 'input_0');
      const find = getInputValue(ctx, node, 'input_1');
      const replace = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${str}.replace(${find}, ${replace})`);
      break;
    }

    case 'string-to-lower': {
      const str = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${str}.tolower()`);
      break;
    }

    case 'string-to-upper': {
      const str = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${str}.toupper()`);
      break;
    }

    case 'string-trim': {
      const str = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${str}.strip()`);
      break;
    }

    case 'string-contains': {
      const str = getInputValue(ctx, node, 'input_0');
      const substr = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'contains');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${str}.find(${substr}) != null`);
      break;
    }

    case 'string-find': {
      const str = getInputValue(ctx, node, 'input_0');
      const substr = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'index');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${str}.find(${substr})`);
      break;
    }

    case 'string-repeat': {
      const str = getInputValue(ctx, node, 'input_0');
      const count = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ""`);
      lines.push(`${ind}for (local i = 0; i < ${count}; i++) {`);
      lines.push(`${ind}  ${resultVar} += ${str}`);
      lines.push(`${ind}}`);
      break;
    }

    case 'string-reverse': {
      const str = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ""`);
      lines.push(`${ind}for (local i = ${str}.len() - 1; i >= 0; i--) {`);
      lines.push(`${ind}  ${resultVar} += ${str}[i]`);
      lines.push(`${ind}}`);
      break;
    }

    // ==================== MATH ====================
    case 'vector-create': {
      const x = getInputValue(ctx, node, 'input_0');
      const y = getInputValue(ctx, node, 'input_1');
      const z = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'vec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = <${x}, ${y}, ${z}>`);
      break;
    }

    case 'vector-add': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'vec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'vector-normalize': {
      const v = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'normalized');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = Normalize(${v})`);
      break;
    }

    case 'vector-lerp': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const t = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = LerpVector(${a}, ${b}, ${t})`);
      break;
    }

    case 'math-add': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'math-multiply': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${a} * ${b}`);
      break;
    }

    case 'math-tan': {
      const value = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = tan(${value})`);
      break;
    }

    case 'math-pow': {
      const base = getInputValue(ctx, node, 'input_0');
      const exponent = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = pow(${base}, ${exponent})`);
      break;
    }

    case 'math-random-float': {
      const min = getInputValue(ctx, node, 'input_0');
      const max = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'rand');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}float ${resultVar} = RandomFloatRange(${min}, ${max})`);
      break;
    }

    // ==================== DATA ====================
    case 'const-string': {
      const value = node.data.value || '';
      ctx.variables.set(`${node.id}:output_0`, `"${value}"`);
      break;
    }

    case 'function-ref': {
      const value = node.data.functionName || 'MyFunction';
      ctx.variables.set(`${node.id}:output_0`, value);
      break;
    }

    case 'const-asset': {
      const value = node.data.value || '$""';
      ctx.variables.set(`${node.id}:output_0`, value);
      break;
    }

    case 'const-loot-tier': {
      const tier = node.data.tier || 'COMMON';
      ctx.variables.set(`${node.id}:output_0`, `eLootTier.${tier}`);
      break;
    }

    case 'const-supported-attachments': {
      const attachments = Array.isArray(node.data.attachments) ? node.data.attachments : [];
      ctx.variables.set(`${node.id}:output_0`, formatLiteral(attachments));
      break;
    }

    case 'const-weapon-type': {
      const weaponType = node.data.weaponType || 'pistol';
      ctx.variables.set(`${node.id}:output_0`, `"${weaponType}"`);
      break;
    }

    case 'entity-classname': {
      const className = node.data.className || 'prop_dynamic';
      ctx.variables.set(`${node.id}:output_0`, `"${className}"`);
      break;
    }

    case 'const-float':
    case 'const-int': {
      const value = node.data.value ?? 0;
      ctx.variables.set(`${node.id}:output_0`, String(value));
      break;
    }

    case 'const-bool': {
      const value = node.data.value ?? false;
      ctx.variables.set(`${node.id}:output_0`, value ? 'true' : 'false');
      break;
    }

    case 'const-vector': {
      const x = node.data.x ?? 0;
      const y = node.data.y ?? 0;
      const z = node.data.z ?? 0;
      ctx.variables.set(`${node.id}:output_0`, `<${x}, ${y}, ${z}>`);
      break;
    }

    // reroute case is handled earlier in the switch (handles both exec and data passthrough)

    case 'array-create': {
      const resultVar = getVarName(ctx, 'arr');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array ${resultVar} = []`);
      break;
    }

    case 'array-append': {
      const array = getInputValue(ctx, node, 'input_1');
      const element = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${array}.append(${element})`);
      ctx.variables.set(`${node.id}:output_1`, array);
      followExec('output_0');
      break;
    }

    case 'array-get': {
      const array = getInputValue(ctx, node, 'input_0');
      const index = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'elem');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${array}[${index}]`);
      break;
    }

    case 'array-length': {
      const array = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'len');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${array}.len()`);
      break;
    }

    case 'table-create': {
      const resultVar = getVarName(ctx, 'tbl');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}table ${resultVar} = {}`);
      break;
    }

    case 'table-get': {
      const table = getInputValue(ctx, node, 'input_0');
      const key = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'val');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${table}[${key}]`);
      break;
    }

    case 'table-set': {
      const table = getInputValue(ctx, node, 'input_1');
      const key = getInputValue(ctx, node, 'input_2');
      const value = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}${table}[${key}] = ${value}`);
      followExec('output_0');
      break;
    }

    // ==================== UTILITIES ====================
    case 'print': {
      const partCount = typeof node.data?.partCount === 'number' ? node.data.partCount : (node.inputs.length - 1);
      const parts: string[] = [];
      for (let i = 0; i < partCount; i++) {
        const part = getInputValue(ctx, node, `input_${i + 1}`);
        if (part && part !== 'null') {
          parts.push(part);
        }
      }
      if (parts.length === 0) {
        lines.push(`${ind}printf("")`);
      } else {
        // Auto-generate format string with %s for each part
        const formatStr = parts.map(() => '%s').join('');
        lines.push(`${ind}printf("${formatStr}", ${parts.join(', ')})`);
      }
      followExec('output_0');
      break;
    }

    case 'get-all-players': {
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetPlayerArray()`);
      break;
    }

    case 'get-players-on-team': {
      const team = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetPlayerArrayOfTeam(${team})`);
      break;
    }

    case 'get-living-players': {
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetLivingPlayers()`);
      break;
    }

    case 'get-living-players-on-team': {
      const team = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetLivingPlayersOnTeam(${team})`);
      break;
    }

    case 'get-local-player': {
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetLocalClientPlayer()`);
      break;
    }

    case 'get-local-view-player': {
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetLocalViewPlayer()`);
      break;
    }

    case 'get-ent-by-index': {
      const index = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'ent');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetEntByIndex(${index})`);
      break;
    }

    case 'get-player-by-index': {
      const index = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = gp()[${index}]`);
      break;
    }

    case 'get-offhand-weapon': {
      const player = getInputValue(ctx, node, 'input_0');
      const slot = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${player}.GetOffhandWeapon(${slot})`);
      break;
    }

    case 'get-weapon-primary-clip-count': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'clipCount');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${weapon}.GetWeaponPrimaryClipCount()`);
      break;
    }

    case 'get-weapon-ammo-pool-type': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'poolType');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${weapon}.GetWeaponAmmoPoolType()`);
      break;
    }

    case 'ammo-type-get-ref-from-index': {
      const poolType = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'ammoType');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = AmmoType_GetRefFromIndex(${poolType})`);
      break;
    }

    case 'create-trigger-cylinder': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const radius = getInputValue(ctx, node, 'input_3');
      const aboveHeight = getInputValue(ctx, node, 'input_4');
      const belowHeight = getInputValue(ctx, node, 'input_5');
      const resultVar = getVarName(ctx, 'trigger');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("trigger_cylinder")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      lines.push(`${ind}${resultVar}.SetAboveHeight(${aboveHeight})`);
      lines.push(`${ind}${resultVar}.SetBelowHeight(${belowHeight})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-trigger-radius-multiple': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const radius = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'trigger');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("trigger_radius_multiple")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-enabled': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const enabled = getInputValue(ctx, node, 'input_2');
      if (enabled === 'true') {
        lines.push(`${ind}${trigger}.Enable()`);
      } else {
        lines.push(`${ind}${trigger}.Disable()`);
      }
      followExec('output_0');
      break;
    }

    case 'trigger-set-radius': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const radius = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetRadius(${radius})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-above-height': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const height = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetAboveHeight(${height})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-below-height': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const height = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetBelowHeight(${height})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-enter-callback': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const callback = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetEnterCallback(${callback})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-leave-callback': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const callback = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetLeaveCallback(${callback})`);
      followExec('output_0');
      break;
    }

    case 'trigger-search-new-touching': {
      const trigger = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${trigger}.SearchForNewTouchingEntity()`);
      followExec('output_0');
      break;
    }

    // ==================== ENTITY CREATION ====================
    case 'create-entity': {
      const className = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      const angles = getInputValue(ctx, node, 'input_3');
      const parent = getInputValue(ctx, node, 'input_4');
      const parentAttach = getInputValue(ctx, node, 'input_5');
      const owner = getInputValue(ctx, node, 'input_6');
      const radius = getInputValue(ctx, node, 'input_7');
      const aboveHeight = getInputValue(ctx, node, 'input_8');
      const belowHeight = getInputValue(ctx, node, 'input_9');
      const model = getInputValue(ctx, node, 'input_10');
      const effect = getInputValue(ctx, node, 'input_11');
      const health = getInputValue(ctx, node, 'input_12');
      const maxHealth = getInputValue(ctx, node, 'input_13');
      const team = getInputValue(ctx, node, 'input_14');
      const scriptName = getInputValue(ctx, node, 'input_15');
      const visible = getInputValue(ctx, node, 'input_16');
      const solid = getInputValue(ctx, node, 'input_17');
      const aiSettings = getInputValue(ctx, node, 'input_18');
      
      const resultVar = getVarName(ctx, 'ent');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      
      lines.push(`${ind}entity ${resultVar} = CreateEntity(${className})`);
      
      // Optional setters - only add if input is connected (not null/undefined placeholder)
      if (origin && origin !== 'null') {
        lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      }
      if (angles && angles !== 'null') {
        lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      }
      if (owner && owner !== 'null') {
        lines.push(`${ind}${resultVar}.SetOwner(${owner})`);
      }
      if (model && model !== 'null' && model !== '""') {
        lines.push(`${ind}${resultVar}.SetValueForModelKey(${model})`);
      }
      if (effect && effect !== 'null' && effect !== '""') {
        lines.push(`${ind}${resultVar}.SetValueForEffectNameKey(${effect})`);
      }
      if (radius && radius !== 'null' && radius !== '0') {
        lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      }
      if (aboveHeight && aboveHeight !== 'null') {
        lines.push(`${ind}${resultVar}.SetAboveHeight(${aboveHeight})`);
      }
      if (belowHeight && belowHeight !== 'null') {
        lines.push(`${ind}${resultVar}.SetBelowHeight(${belowHeight})`);
      }
      if (maxHealth && maxHealth !== 'null') {
        lines.push(`${ind}${resultVar}.SetMaxHealth(${maxHealth})`);
      }
      if (health && health !== 'null') {
        lines.push(`${ind}${resultVar}.SetHealth(${health})`);
      }
      if (team && team !== 'null') {
        lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      }
      if (scriptName && scriptName !== 'null' && scriptName !== '""') {
        lines.push(`${ind}${resultVar}.SetScriptName(${scriptName})`);
      }
      if (aiSettings && aiSettings !== 'null' && aiSettings !== '""') {
        lines.push(`${ind}SetSpawnOption_AISettings(${resultVar}, ${aiSettings})`);
      }
      if (visible === 'false') {
        lines.push(`${ind}${resultVar}.Hide()`);
      }
      if (solid === 'false') {
        lines.push(`${ind}${resultVar}.NotSolid()`);
      } else if (solid === 'true') {
        lines.push(`${ind}${resultVar}.Solid()`);
      }
      
      // KeyValues from connected KV nodes - collect all connections to input_19
      const kvConnections = ctx.connections.filter(c => 
        c.to.nodeId === node.id && c.to.portId === 'input_19'
      );
      
      for (const conn of kvConnections) {
        const kvNode = ctx.nodes.find(n => n.id === conn.from.nodeId);
        if (kvNode) {
          const kvType = kvNode.data.type || kvNode.type;
          
          // Helper to get value from input or fall back to node data
          const getKvValue = (inputId: string, dataKey: string, defaultVal: any) => {
            const inputVal = getInputValue(ctx, kvNode, inputId);
            if (inputVal && inputVal !== 'null') return inputVal;
            if (kvNode.data[dataKey] !== undefined) return formatLiteral(kvNode.data[dataKey]);
            return formatLiteral(defaultVal);
          };
          
          switch (kvType) {
            case 'kv-solid': {
              const val = getKvValue('input_0', 'value', 0);
              lines.push(`${ind}${resultVar}.kv.solid = ${val}`);
              break;
            }
            case 'kv-rendercolor': {
              const val = getKvValue('input_0', 'value', '255,255,255');
              lines.push(`${ind}${resultVar}.kv.rendercolor = ${val}`);
              break;
            }
            case 'kv-renderamt': {
              const val = getKvValue('input_0', 'value', 255);
              lines.push(`${ind}${resultVar}.kv.renderamt = ${val}`);
              break;
            }
            case 'kv-rendermode': {
              const val = getKvValue('input_0', 'value', 0);
              lines.push(`${ind}${resultVar}.kv.rendermode = ${val}`);
              break;
            }
            case 'kv-visibility-flags': {
              const val = getKvValue('input_0', 'value', 7);
              lines.push(`${ind}${resultVar}.kv.VisibilityFlags = ${val}`);
              break;
            }
            case 'kv-spawnflags': {
              const val = getKvValue('input_0', 'value', 0);
              lines.push(`${ind}${resultVar}.kv.spawnflags = ${val}`);
              break;
            }
            case 'kv-collision-group': {
              const val = getKvValue('input_0', 'value', 0);
              lines.push(`${ind}${resultVar}.kv.CollisionGroup = ${val}`);
              break;
            }
            case 'kv-start-active': {
              const val = getKvValue('input_0', 'value', 1);
              lines.push(`${ind}${resultVar}.kv.start_active = ${val}`);
              break;
            }
            case 'kv-fadedist': {
              const val = getKvValue('input_0', 'value', -1);
              lines.push(`${ind}${resultVar}.kv.fadedist = ${val}`);
              break;
            }
            case 'kv-modelscale': {
              const val = getKvValue('input_0', 'value', 1.0);
              lines.push(`${ind}${resultVar}.kv.modelscale = ${val}`);
              break;
            }
            case 'kv-trigger-filter': {
              const filterNonChar = getKvValue('input_0', 'filterNonCharacter', '0');
              const filterPlayer = getKvValue('input_1', 'filterPlayer', '1');
              const filterNpc = getKvValue('input_2', 'filterNpc', '1');
              lines.push(`${ind}${resultVar}.kv.triggerFilterNonCharacter = ${filterNonChar}`);
              lines.push(`${ind}${resultVar}.kv.triggerFilterPlayer = ${filterPlayer}`);
              lines.push(`${ind}${resultVar}.kv.triggerFilterNpc = ${filterNpc}`);
              break;
            }
            case 'kv-custom': {
              const key = getKvValue('input_0', 'key', 'enabled');
              const val = getKvValue('input_1', 'value', '1');
              // Remove quotes from key if present
              const keyClean = String(key).replace(/^"|"$/g, '');
              lines.push(`${ind}${resultVar}.kv.${keyClean} = ${val}`);
              break;
            }
          }
        }
      }
      
      // DispatchSpawn before parenting
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      
      // Parent after spawn
      if (parent && parent !== 'null') {
        if (parentAttach && parentAttach !== 'null' && parentAttach !== '""') {
          lines.push(`${ind}${resultVar}.SetParent(${parent}, ${parentAttach}, true, 0.0)`);
        } else {
          lines.push(`${ind}${resultVar}.SetParent(${parent}, "", true, 0.0)`);
        }
      }
      
      followExec('output_0');
      break;
    }

    case 'create-script-mover': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'mover');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("script_mover")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-prop-dynamic': {
      const model = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      const angles = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'prop');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("prop_dynamic")`);
      lines.push(`${ind}${resultVar}.SetValueForModelKey(${model})`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-prop-physics': {
      const model = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      const angles = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'physProp');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("prop_physics")`);
      lines.push(`${ind}${resultVar}.SetValueForModelKey(${model})`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}${resultVar}.kv.solid = SOLID_VPHYSICS`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-info-target': {
      const origin = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'infoTarget');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("info_target")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-particle-system': {
      const effect = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      const startActive = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'particleSys');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("info_particle_system")`);
      lines.push(`${ind}${resultVar}.SetValueForEffectNameKey(${effect})`);
      lines.push(`${ind}${resultVar}.kv.start_active = ${startActive} ? 1 : 0`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-control-point': {
      const origin = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'cpoint');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("info_placement_helper")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-ambient-generic': {
      const sound = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'ambSound');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("ambient_generic")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-vortex-sphere': {
      const origin = getInputValue(ctx, node, 'input_1');
      const radius = getInputValue(ctx, node, 'input_2');
      const height = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'vortex');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("vortex_sphere")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      lines.push(`${ind}${resultVar}.SetAboveHeight(${height})`);
      lines.push(`${ind}${resultVar}.SetBelowHeight(${height})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-zipline': {
      const startPos = getInputValue(ctx, node, 'input_1');
      const endPos = getInputValue(ctx, node, 'input_2');
      const startVar = getVarName(ctx, 'zipStart');
      const endVar = getVarName(ctx, 'zipEnd');
      ctx.variables.set(`${node.id}:output_1`, startVar);
      ctx.variables.set(`${node.id}:output_2`, endVar);
      lines.push(`${ind}entity ${startVar} = CreateEntity("zipline")`);
      lines.push(`${ind}entity ${endVar} = CreateEntity("zipline_end")`);
      lines.push(`${ind}${startVar}.SetOrigin(${startPos})`);
      lines.push(`${ind}${endVar}.SetOrigin(${endPos})`);
      lines.push(`${ind}${startVar}.kv.ZiplineAutoDetachDistance = 160`);
      lines.push(`${ind}${endVar}.kv.ZiplineAutoDetachDistance = 160`);
      lines.push(`${ind}${startVar}.kv.Material = "cable/zipline.vmt"`);
      lines.push(`${ind}${startVar}.LinkToEnt(${endVar})`);
      lines.push(`${ind}DispatchSpawn(${startVar})`);
      lines.push(`${ind}DispatchSpawn(${endVar})`);
      followExec('output_0');
      break;
    }

    case 'create-point-viewcontrol': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'camera');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("point_viewcontrol")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    // ==================== NPC CREATION ====================
    case 'create-npc-dummie': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'dummy');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_dummie")`);
      lines.push(`${ind}SetSpawnOption_AISettings(${resultVar}, "npc_training_dummy")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-prowler': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'prowler');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_prowler")`);
      lines.push(`${ind}SetSpawnOption_AISettings(${resultVar}, "npc_prowler")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-spectre': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'spectre');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_spectre")`);
      lines.push(`${ind}SetSpawnOption_AISettings(${resultVar}, "npc_spectre")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-marvin': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'marvin');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_marvin")`);
      lines.push(`${ind}SetSpawnOption_AISettings(${resultVar}, "npc_marvin")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-drone': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'drone');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_drone")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-dropship': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'dropship');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_dropship")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-npc-turret': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const team = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'turret');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("npc_turret_sentry")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}SetTeam(${resultVar}, ${team})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    // ==================== ENTITY SETUP ====================
    case 'set-model': {
      const entity = getInputValue(ctx, node, 'input_1');
      const model = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetValueForModelKey(${model})`);
      followExec('output_0');
      break;
    }

    case 'set-effect-name': {
      const entity = getInputValue(ctx, node, 'input_1');
      const effect = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetValueForEffectNameKey(${effect})`);
      followExec('output_0');
      break;
    }

    case 'set-entity-kv': {
      const entity = getInputValue(ctx, node, 'input_1');
      const value = getInputValue(ctx, node, 'input_2');
      const property = node.data?.property || 'solid';
      lines.push(`${ind}${entity}.kv.${property} = ${value}`);
      followExec('output_0');
      break;
    }

    case 'set-spawn-option-ai': {
      const npc = getInputValue(ctx, node, 'input_1');
      const aiSettings = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}SetSpawnOption_AISettings(${npc}, ${aiSettings})`);
      followExec('output_0');
      break;
    }

    case 'set-behavior-selector': {
      const npc = getInputValue(ctx, node, 'input_1');
      const behavior = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${npc}.SetBehaviorSelector(${behavior})`);
      followExec('output_0');
      break;
    }

    case 'enable-npc-flag': {
      const npc = getInputValue(ctx, node, 'input_1');
      const flags = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${npc}.EnableNPCFlag(${flags})`);
      followExec('output_0');
      break;
    }

    case 'dispatch-spawn': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}DispatchSpawn(${entity})`);
      followExec('output_0');
      break;
    }

    case 'take-primary-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}TakePrimaryWeapon(${player})`);
      followExec('output_0');
      break;
    }

    case 'set-active-weapon-by-name': {
      const player = getInputValue(ctx, node, 'input_1');
      const slot = getInputValue(ctx, node, 'input_2');
      const weaponName = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}${player}.SetActiveWeaponByName(${slot}, ${weaponName})`);
      followExec('output_0');
      break;
    }

    // ==================== PASSIVES ====================
    case 'give-passive': {
      const player = getInputValue(ctx, node, 'input_1');
      const passive = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GivePassive(${player}, ${passive})`);
      followExec('output_0');
      break;
    }

    case 'take-passive': {
      const player = getInputValue(ctx, node, 'input_1');
      const passive = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}TakePassive(${player}, ${passive})`);
      followExec('output_0');
      break;
    }

    case 'take-all-passives': {
      const player = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}TakeAllPassives(${player})`);
      followExec('output_0');
      break;
    }

    case 'get-all-passives-for-player': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'passives');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<int> ${resultVar} = GetAllPassivesForPlayer(${player})`);
      break;
    }

    case 'player-has-passive': {
      const player = getInputValue(ctx, node, 'input_0');
      const passive = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'hasPassive');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = PlayerHasPassive(${player}, ${passive})`);
      break;
    }

    // ==================== CHARACTER ABILITIES ====================
    case 'character-get-tactical-ability': {
      const character = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'tacticalAbility');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}ItemFlavor ${resultVar} = CharacterClass_GetTacticalAbility(${character})`);
      break;
    }

    case 'character-get-ultimate-ability': {
      const character = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'ultimateAbility');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}ItemFlavor ${resultVar} = CharacterClass_GetUltimateAbility(${character})`);
      break;
    }

    case 'character-get-passive-ability': {
      const character = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'passiveAbility');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}ItemFlavor ${resultVar} = CharacterClass_GetPassiveAbility(${character})`);
      break;
    }

    // ==================== SURVIVAL LOOT ====================
    case 'survival-get-all-loot': {
      const resultVar = getVarName(ctx, 'allLoot');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = SURVIVAL_Loot_GetAllLoot()`);
      break;
    }

    case 'survival-pickup-item': {
      const loot = getInputValue(ctx, node, 'input_1');
      const player = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'pickupSuccess');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}bool ${resultVar} = Survival_PickupItem(${loot}, ${player})`);
      followExec('output_0');
      break;
    }

    case 'survival-add-to-inventory': {
      const player = getInputValue(ctx, node, 'input_1');
      const itemRef = getInputValue(ctx, node, 'input_2');
      const count = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'amountAdded');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}int ${resultVar} = SURVIVAL_AddToPlayerInventory(${player}, ${itemRef}, ${count})`);
      followExec('output_0');
      break;
    }

    case 'survival-remove-from-inventory': {
      const player = getInputValue(ctx, node, 'input_1');
      const itemRef = getInputValue(ctx, node, 'input_2');
      const count = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}SURVIVAL_RemoveFromPlayerInventory(${player}, ${itemRef}, ${count})`);
      followExec('output_0');
      break;
    }

    case 'survival-get-player-inventory': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'inventory');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<ConsumableInventoryItem> ${resultVar} = SURVIVAL_GetPlayerInventory(${player})`);
      break;
    }

    case 'survival-count-items-in-inventory': {
      const player = getInputValue(ctx, node, 'input_0');
      const itemRef = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'itemCount');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = SURVIVAL_CountItemsInInventory(${player}, ${itemRef})`);
      break;
    }

    case 'survival-has-item-in-inventory': {
      const player = getInputValue(ctx, node, 'input_0');
      const itemRef = getInputValue(ctx, node, 'input_1');
      const count = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'hasItem');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = SURVIVAL_HasSpecificItemInInventory(${player}, ${itemRef}, ${count})`);
      break;
    }

    // ==================== COMPARISONS ====================
    case 'compare-equal': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `${a} == ${b}`);
      break;
    }

    case 'compare-greater': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `${a} > ${b}`);
      break;
    }

    case 'compare-less': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `${a} < ${b}`);
      break;
    }

    // ==================== SWITCH ====================
    case 'switch': {
      const value = getInputValue(ctx, node, 'input_1');
      // Flush pending lines
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}switch (${value})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      // Cases are connected to the switch node via the switch-case nodes
      // Default case
      followExec('output_0');
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      break;
    }

    case 'switch-case': {
      const matchValue = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}case ${matchValue}:`);
      ctx.indentLevel++;
      followExec('output_0');
      ctx.indentLevel--;
      break;
    }

    case 'break': {
      lines.push(`${ind}break`);
      break;
    }

    case 'continue': {
      lines.push(`${ind}continue`);
      break;
    }

    // ==================== STRUCTS & ENUMS ====================
    case 'struct-define': {
      // Struct definitions are generated at file level, not inline
      // This is handled separately in generateCode()
      break;
    }

    case 'struct-create': {
      const structName = node.data.structName || 'MyStruct';
      const resultVar = getVarName(ctx, 'instance');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}${structName} ${resultVar}`);
      followExec('output_0');
      break;
    }

    case 'struct-get-field': {
      const structVar = getInputValue(ctx, node, 'input_0');
      const fieldName = node.data.fieldName || 'field1';
      const resultVar = getVarName(ctx, 'val');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${structVar}.${fieldName}`);
      break;
    }

    case 'struct-set-field': {
      const structVar = getInputValue(ctx, node, 'input_1');
      const value = getInputValue(ctx, node, 'input_2');
      const fieldName = node.data.fieldName || 'field1';
      lines.push(`${ind}${structVar}.${fieldName} = ${value}`);
      followExec('output_0');
      break;
    }

    case 'enum-define': {
      // Enum definitions are generated at file level, not inline
      // This is handled separately in generateCode()
      break;
    }

    case 'enum-value': {
      const enumName = node.data.enumName || 'eGameState';
      const valueName = node.data.valueName || 'Playing';
      ctx.variables.set(`${node.id}:output_0`, `${enumName}.${valueName}`);
      break;
    }

    // ==================== ARRAYS (EXTENDED) ====================
    case 'array-create-typed': {
      // Skip if already generated as global variable
      if ((ctx as any).globalVarNodeIds?.has(node.id)) {
        followExec('output_0');
        break;
      }
      const elementType = node.data.elementType || 'var';
      const resultVar = node.data.varName || getVarName(ctx, 'arr');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}array<${elementType}> ${resultVar} = []`);
      followExec('output_0');
      break;
    }

    case 'array-extend': {
      const array = getInputValue(ctx, node, 'input_1');
      const other = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${array}.extend(${other})`);
      ctx.variables.set(`${node.id}:output_1`, array);
      followExec('output_0');
      break;
    }

    case 'array-remove': {
      const array = getInputValue(ctx, node, 'input_1');
      const element = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${array}.removebyvalue(${element})`);
      ctx.variables.set(`${node.id}:output_1`, array);
      followExec('output_0');
      break;
    }

    case 'array-remove-by-index': {
      const array = getInputValue(ctx, node, 'input_1');
      const index = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'removed');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${array}.remove(${index})`);
      followExec('output_0');
      break;
    }

    case 'array-set': {
      const array = getInputValue(ctx, node, 'input_1');
      const index = getInputValue(ctx, node, 'input_2');
      const value = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}${array}[${index}] = ${value}`);
      followExec('output_0');
      break;
    }

    case 'array-contains': {
      const array = getInputValue(ctx, node, 'input_0');
      const element = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `${array}.contains(${element})`);
      break;
    }

    case 'array-find': {
      const array = getInputValue(ctx, node, 'input_0');
      const element = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'idx');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${array}.find(${element})`);
      break;
    }

    case 'array-clear': {
      const array = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${array}.clear()`);
      followExec('output_0');
      break;
    }

    case 'array-resize': {
      const array = getInputValue(ctx, node, 'input_1');
      const size = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${array}.resize(${size})`);
      followExec('output_0');
      break;
    }

    case 'array-randomize': {
      const array = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${array}.randomize()`);
      ctx.variables.set(`${node.id}:output_1`, array);
      followExec('output_0');
      break;
    }

    case 'array-getrandom': {
      const array = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'elem');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${array}.getrandom()`);
      break;
    }

    case 'array-slice': {
      const array = getInputValue(ctx, node, 'input_0');
      const start = getInputValue(ctx, node, 'input_1');
      const end = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'slice');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${array}.slice(${start}, ${end})`);
      break;
    }

    // ==================== TABLES (EXTENDED) ====================
    case 'table-create-typed': {
      // Skip if already generated as global variable
      if ((ctx as any).globalVarNodeIds?.has(node.id)) {
        followExec('output_0');
        break;
      }
      const keyType = node.data.keyType || 'string';
      const valueType = node.data.valueType || 'var';
      const resultVar = node.data.varName || getVarName(ctx, 'tbl');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}table<${keyType}, ${valueType}> ${resultVar} = {}`);
      followExec('output_0');
      break;
    }

    case 'table-add-slot': {
      const table = getInputValue(ctx, node, 'input_1');
      const key = getInputValue(ctx, node, 'input_2');
      const value = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}${table}[${key}] <- ${value}`);
      followExec('output_0');
      break;
    }

    case 'table-delete': {
      const table = getInputValue(ctx, node, 'input_1');
      const key = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}delete ${table}[${key}]`);
      followExec('output_0');
      break;
    }

    case 'table-keys': {
      const table = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'keys');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      // Squirrel doesn't have a built-in keys() method, generate a workaround
      lines.push(`${ind}array ${resultVar} = []`);
      lines.push(`${ind}foreach (key, val in ${table})`);
      lines.push(`${ind}    ${resultVar}.append(key)`);
      break;
    }

    case 'table-values': {
      const table = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'values');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      // Generate foreach loop to extract values
      lines.push(`${ind}array ${resultVar} = []`);
      lines.push(`${ind}foreach (key, val in ${table})`);
      lines.push(`${ind}    ${resultVar}.append(val)`);
      break;
    }

    case 'table-clear': {
      const table = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${table}.clear()`);
      followExec('output_0');
      break;
    }

    case 'table-has-key': {
      const table = getInputValue(ctx, node, 'input_0');
      const key = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `(${key} in ${table})`);
      break;
    }

    // ==================== DATA (EXTENDED) ====================
    case 'variable-declare': {
      const varName = node.data.name || 'myVar';
      const varType = node.data.varType || 'var';
      const initialValue = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_1`, varName);
      lines.push(`${ind}${varType} ${varName} = ${initialValue}`);
      followExec('output_0');
      break;
    }

    case 'define-const': {
      // Const definitions are generated at file level for globals,
      // or inline for locals - handled in generateCode()
      const constName = node.data.constName || 'MY_CONSTANT';
      ctx.variables.set(`${node.id}:output_0`, constName);
      break;
    }

    case 'global-variable': {
      // Make Global node - just a marker, generation is handled at file level in generateCode()
      // This node doesn't produce any inline code
      break;
    }

    case 'local-variable': {
      // Make Local node - just a marker, generation is handled at file level in generateCode()
      // This node doesn't produce any inline code
      break;
    }

    default: {
      lines.push(`${ind}// TODO: ${node.type} - ${node.label}`);
      const execOuts = node.outputs.filter(p => p.type === 'exec');
      if (execOuts.length > 0) {
        followExec(execOuts[0].id);
      }
    }
  }

  // Prepend any pending lines (from data nodes that were generated to resolve inputs)
  const pendingCode = ctx.pendingLines.join('\n');
  ctx.pendingLines = []; // Clear pending lines after using
  
  const nodeCode = lines.filter(l => l.trim()).join('\n');
  if (pendingCode && nodeCode) {
    return pendingCode + '\n' + nodeCode;
  }
  return pendingCode || nodeCode;
}

function generateFromNode(ctx: CodeGenContext, nodeId: string): string {
  if (ctx.visitedNodes.has(nodeId)) return '';

  const node = ctx.nodeMap.get(nodeId);
  if (!node) return '';

  ctx.visitedNodes.add(nodeId);
  return generateNodeCode(ctx, node);
}

// Generate thread function body
function generateThreadFunction(ctx: CodeGenContext, threadFunc: ThreadFunction): string {
  const lines: string[] = [];

  lines.push(`void function ${threadFunc.name}()`);
  lines.push('{');

  ctx.indentLevel = 1;

  // Generate the thread body from the output port
  const bodyConns = getOutputConnections(ctx, threadFunc.nodeId, threadFunc.outputPortId);
  for (const conn of bodyConns) {
    // Don't skip visited - we need to regenerate for thread context
    const node = ctx.nodeMap.get(conn.to.nodeId);
    if (node) {
      const code = generateNodeCode(ctx, node);
      if (code) lines.push(code);
    }
  }

  lines.push('}');
  return lines.join('\n');
}

export function generateCode(nodes: ScriptNode[], connections: NodeConnection[]): string {
  if (nodes.length === 0) {
    return '// No nodes in the visual script\n// Add nodes from the palette to get started';
  }

  const ctx: CodeGenContext = {
    nodes,
    connections,
    nodeMap: new Map(nodes.map(n => [n.id, n])),
    visitedNodes: new Set(),
    indentLevel: 0,
    variables: new Map(),
    varCounter: 0,
    threadFunctions: [],
    pendingLines: [],
    portals: new Map(),
  };

  const output: string[] = [];

  output.push('// Generated by R5V Mod Studio Visual Scripting');
  output.push('// https://github.com/r5valkyrie/r5v_mod_studio');
  output.push('');
  const serverInit = nodes.find(n => n.type === 'init-server');
  const clientInit = nodes.find(n => n.type === 'init-client');
  const uiInit = nodes.find(n => n.type === 'init-ui');

  // Collect all global custom functions for context detection later
  const globalCustomFunctions = nodes.filter(n => n.type === 'custom-function' && n.data.isGlobal === true);

  // Server callback event types that have Register input
  const serverCallbackTypes = [
    'on-entities-did-load', 'on-client-connected', 'on-client-disconnected', 'on-player-killed', 'on-player-respawned',
    'on-npc-killed', 'on-client-connecting', 'on-entity-changed-team', 'on-player-assist', 'on-player-inventory-changed',
    'on-weapon-attack', 'on-death-box-spawned', 'on-game-state-enter', 'on-player-weapon-activated', 'on-player-used-offhand',
    'on-leave-match', 'on-use-button-pressed', 'on-use-button-released', 'on-player-class-changed', 'on-vehicle-launch',
    'on-vehicle-collide', 'on-player-changed-team', 'on-player-zoom-in', 'on-player-zoom-out', 'on-passive-changed',
    'on-ping-created', 'on-player-match-state-changed', 'on-deathfield-stage-changed', 'on-bleedout-started', 'on-bleedout-ended',
    'on-player-life-state-changed', 'on-you-respawned', 'on-you-died', 'on-player-scored', 'on-lootbin-opened',
    'on-player-add-weapon-mod', 'on-player-remove-weapon-mod', 'on-grappled', 'on-grapple-detached'
  ];

  // Helper to trace back from a node to find which init contexts it belongs to
  const traceContextsFromNode = (startNodeId: string): Set<string> => {
    const contexts = new Set<string>();
    const visited = new Set<string>();
    const queue = [startNodeId];
    
    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      if (visited.has(nodeId)) continue;
      visited.add(nodeId);
      
      const node = ctx.nodeMap.get(nodeId);
      if (!node) continue;
      
      if (node.type === 'init-server') contexts.add('SERVER');
      else if (node.type === 'init-client') contexts.add('CLIENT');
      else if (node.type === 'init-ui') contexts.add('UI');
      
      // Find all nodes that connect TO this node (predecessors)
      const incomingConns = connections.filter(c => c.to.nodeId === nodeId);
      for (const conn of incomingConns) {
        queue.push(conn.from.nodeId);
      }
    }
    
    return contexts;
  };

  // Helper to determine the context(s) (SERVER/CLIENT/UI) for a function based on node type
  // Returns an array of contexts, or null if no specific context
  const getFunctionContexts = (eventNode: ScriptNode): string[] | null => {
    // For server callback events, trace back from the Register input to find contexts
    if (serverCallbackTypes.includes(eventNode.type)) {
      const contexts = traceContextsFromNode(eventNode.id);
      
      if (contexts.size === 0) {
        // Default to SERVER if no context found (these are server-side callbacks)
        return ['SERVER'];
      }
      
      return Array.from(contexts).sort();
    }
    
    if (eventNode.type === 'custom-function') {
      const funcName = eventNode.data.functionName || `${eventNode.type.replace(/-/g, '_')}_handler`;
      const callNodes = nodes.filter(n => n.type === 'call-function' && n.data.function === funcName);
      const contexts = new Set<string>();
      
      for (const callNode of callNodes) {
        const callContexts = traceContextsFromNode(callNode.id);
        for (const ctx of callContexts) {
          contexts.add(ctx);
        }
      }
      
      if (contexts.size === 0) {
        return null;
      }
      
      // Return sorted array of contexts for consistent output
      return Array.from(contexts).sort();
    }
    
    return null;
  };

  // Helper to format context directive (e.g., "SERVER" or "SERVER || CLIENT || UI")
  const formatContextDirective = (contexts: string[]): string => {
    return contexts.join(' || ');
  };

  // === OUTPUT STRUCT DEFINITIONS AT TOP OF FILE ===
  const structDefNodes = nodes.filter(n => n.type === 'struct-define');
  for (const structNode of structDefNodes) {
    const structName = structNode.data.structName || 'MyStruct';
    const accessorName = structNode.data.accessorName || '';
    const isGlobal = structNode.data.isGlobal || false;
    const fieldCount = typeof structNode.data.fieldCount === 'number' ? structNode.data.fieldCount : 0;
    const fieldNames = Array.isArray(structNode.data.fieldNames) ? structNode.data.fieldNames : [];
    const fieldTypes = Array.isArray(structNode.data.fieldTypes) ? structNode.data.fieldTypes : [];
    const fieldDefaults = Array.isArray(structNode.data.fieldDefaults) ? structNode.data.fieldDefaults : [];

    // Struct header with required name
    output.push(`${isGlobal ? 'global ' : ''}struct ${structName}`);
    output.push('{');
    for (let i = 0; i < fieldCount; i++) {
      const fName = fieldNames[i] || `field${i + 1}`;
      const fType = fieldTypes[i] || 'var';
      const fDefault = fieldDefaults[i];
      // Types like table, array, struct should not have default values in struct definitions
      const isContainerType = fType.startsWith('table') || fType.startsWith('array') || fType === 'struct';
      if (!isContainerType && fDefault !== undefined && fDefault !== null && fDefault !== '') {
        output.push(`    ${fType} ${fName} = ${fDefault}`);
      } else {
        output.push(`    ${fType} ${fName}`);
      }
    }
    // Closing brace with optional accessor name
    if (accessorName) {
      output.push(`} ${accessorName}`);
    } else {
      output.push('}');
    }
    output.push('');
  }

  // === OUTPUT ENUM DEFINITIONS AT TOP OF FILE ===
  const enumDefNodes = nodes.filter(n => n.type === 'enum-define');
  for (const enumNode of enumDefNodes) {
    const enumName = enumNode.data.enumName || 'MyEnum';
    const isGlobal = enumNode.data.isGlobal !== false; // default to global
    const valueCount = typeof enumNode.data.valueCount === 'number' ? enumNode.data.valueCount : 0;
    const valueNames = Array.isArray(enumNode.data.valueNames) ? enumNode.data.valueNames : [];
    const explicitValues = Array.isArray(enumNode.data.explicitValues) ? enumNode.data.explicitValues : [];

    output.push(`${isGlobal ? 'global ' : ''}enum ${enumName}`);
    output.push('{');
    for (let i = 0; i < valueCount; i++) {
      const vName = valueNames[i] || `VALUE_${i}`;
      const vExplicit = explicitValues[i];
      if (vExplicit !== undefined && vExplicit !== null) {
        output.push(`    ${vName} = ${vExplicit},`);
      } else {
        output.push(`    ${vName},`);
      }
    }
    output.push('}');
    output.push('');
  }

  // === OUTPUT GLOBAL CONST DEFINITIONS AT TOP OF FILE ===
  const globalConstNodes = nodes.filter(n => n.type === 'define-const' && n.data.isGlobal !== false);
  for (const constNode of globalConstNodes) {
    const constName = constNode.data.constName || 'MY_CONSTANT';
    const constType = constNode.data.constType || 'int';
    const constValue = constNode.data.constValue ?? '0';
    
    // Format: global const [type] NAME = value
    if (constType === 'int' || constType === 'float' || constType === 'bool') {
      output.push(`global const ${constType} ${constName} = ${constValue}`);
    } else if (constType === 'string') {
      // Ensure string is quoted
      const quotedValue = constValue.startsWith('"') ? constValue : `"${constValue}"`;
      output.push(`global const ${constName} = ${quotedValue}`);
    } else if (constType === 'vector') {
      output.push(`global const ${constName} = ${constValue}`);
    } else if (constType === 'asset') {
      // Assets use $"path" format
      const assetValue = constValue.startsWith('$') ? constValue : `$"${constValue}"`;
      output.push(`global const ${constName} = ${assetValue}`);
    } else {
      output.push(`global const ${constName} = ${constValue}`);
    }
  }
  
  // === OUTPUT LOCAL CONST DEFINITIONS ===
  const localConstNodes = nodes.filter(n => n.type === 'define-const' && n.data.isGlobal === false);
  for (const constNode of localConstNodes) {
    const constName = constNode.data.constName || 'MY_CONSTANT';
    const constType = constNode.data.constType || 'int';
    const constValue = constNode.data.constValue ?? '0';
    
    // Format: const [type] NAME = value (no global prefix)
    if (constType === 'int' || constType === 'float' || constType === 'bool') {
      output.push(`const ${constType} ${constName} = ${constValue}`);
    } else if (constType === 'string') {
      const quotedValue = constValue.startsWith('"') ? constValue : `"${constValue}"`;
      output.push(`const ${constName} = ${quotedValue}`);
    } else if (constType === 'vector') {
      output.push(`const ${constName} = ${constValue}`);
    } else if (constType === 'asset') {
      const assetValue = constValue.startsWith('$') ? constValue : `$"${constValue}"`;
      output.push(`const ${constName} = ${assetValue}`);
    } else {
      output.push(`const ${constName} = ${constValue}`);
    }
  }
  if (globalConstNodes.length > 0 || localConstNodes.length > 0) {
    output.push('');
  }

  // === OUTPUT ALL GLOBAL DECLARATIONS AT TOP OF FILE ===
  
  // Server init global declaration
  if (serverInit) {
    output.push('#if SERVER');
    output.push(`global function ${serverInit.data.functionName || 'CodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }
  // Client init global declaration
  if (clientInit) {
    output.push('#if CLIENT');
    output.push(`global function ${clientInit.data.functionName || 'ClientCodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }
  // UI init global declaration
  if (uiInit) {
    output.push('#if UI');
    output.push(`global function ${uiInit.data.functionName || 'UICodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }
  
  // Global custom function declarations (grouped by context directive key)
  // Use a Map to group by the formatted context directive (e.g., "SERVER", "CLIENT || SERVER", etc.)
  const globalsByContext = new Map<string, string[]>();
  
  for (const funcNode of globalCustomFunctions) {
    const funcName = funcNode.data.functionName || 'MyFunction';
    const funcContexts = getFunctionContexts(funcNode);
    
    // Determine the directive key
    const directiveKey = funcContexts ? formatContextDirective(funcContexts) : '';
    
    if (!globalsByContext.has(directiveKey)) {
      globalsByContext.set(directiveKey, []);
    }
    globalsByContext.get(directiveKey)!.push(`global function ${funcName}`);
  }
  
  // Output global declarations grouped by context
  for (const [directive, globals] of globalsByContext) {
    if (directive) {
      output.push(`#if ${directive}`);
    }
    for (const g of globals) output.push(g);
    if (directive) {
      output.push('#endif');
    }
    output.push('');
  }

  // === OUTPUT FILE-LEVEL VARIABLE DECLARATIONS (arrays, tables, etc. connected to make-global/make-local nodes) ===
  const makeGlobalNodes = nodes.filter(n => n.type === 'global-variable');
  const makeLocalNodes = nodes.filter(n => n.type === 'local-variable');
  const fileLevelVarNodeIds = new Set<string>(); // Track which nodes are file-level (skip inline generation)
  
  // Helper function to generate variable declaration
  const generateVarDeclaration = (targetNode: ScriptNode, isGlobal: boolean): string | null => {
    const prefix = isGlobal ? 'global ' : '';
    
    if (targetNode.type === 'array-create-typed') {
      const elementType = targetNode.data.elementType || 'var';
      const varName = targetNode.data.varName || `g_arr_${ctx.varCounter++}`;
      const initialValues = Array.isArray(targetNode.data.initialValues) ? targetNode.data.initialValues : [];
      ctx.variables.set(`${targetNode.id}:output_1`, varName);
      
      if (initialValues.length > 0) {
        return `${prefix}array<${elementType}> ${varName} = [${initialValues.join(', ')}]`;
      } else {
        return `${prefix}array<${elementType}> ${varName} = []`;
      }
    } else if (targetNode.type === 'array-create') {
      const varName = targetNode.data.varName || `g_arr_${ctx.varCounter++}`;
      ctx.variables.set(`${targetNode.id}:output_0`, varName);
      return `${prefix}array<var> ${varName} = []`;
    } else if (targetNode.type === 'table-create-typed') {
      const keyType = targetNode.data.keyType || 'string';
      const valueType = targetNode.data.valueType || 'var';
      const varName = targetNode.data.varName || `g_tbl_${ctx.varCounter++}`;
      const entryCount = typeof targetNode.data.entryCount === 'number' ? targetNode.data.entryCount : 0;
      const entryKeys = Array.isArray(targetNode.data.entryKeys) ? targetNode.data.entryKeys : [];
      const entryValues = Array.isArray(targetNode.data.entryValues) ? targetNode.data.entryValues : [];
      ctx.variables.set(`${targetNode.id}:output_1`, varName);
      
      if (entryCount > 0 && entryKeys.length > 0) {
        const pairs = [];
        for (let i = 0; i < entryCount; i++) {
          const k = entryKeys[i] || `key${i}`;
          const v = entryValues[i] || 'null';
          pairs.push(`${k} = ${v}`);
        }
        return `${prefix}table<${keyType}, ${valueType}> ${varName} = { ${pairs.join(', ')} }`;
      } else {
        return `${prefix}table<${keyType}, ${valueType}> ${varName} = {}`;
      }
    } else if (targetNode.type === 'table-create') {
      const varName = targetNode.data.varName || `g_tbl_${ctx.varCounter++}`;
      ctx.variables.set(`${targetNode.id}:output_0`, varName);
      return `${prefix}table ${varName} = {}`;
    } else if (targetNode.type === 'variable-declare') {
      const varName = targetNode.data.name || 'myVar';
      const varType = targetNode.data.varType || 'var';
      const initialValue = targetNode.data.initialValue;
      ctx.variables.set(`${targetNode.id}:output_1`, varName);
      
      if (initialValue !== undefined && initialValue !== '') {
        return `${prefix}${varType} ${varName} = ${initialValue}`;
      } else {
        return `${prefix}${varType} ${varName}`;
      }
    }
    return null;
  };
  
  // Process Make Global nodes (with "global" prefix)
  for (const makeGlobalNode of makeGlobalNodes) {
    const execConns = connections.filter(c => c.from.nodeId === makeGlobalNode.id && c.from.portId === 'output_0');
    for (const conn of execConns) {
      const targetNode = ctx.nodeMap.get(conn.to.nodeId);
      if (!targetNode) continue;
      fileLevelVarNodeIds.add(targetNode.id);
      const decl = generateVarDeclaration(targetNode, true);
      if (decl) output.push(decl);
    }
  }
  
  // Process Make Local nodes (without "global" prefix)
  for (const makeLocalNode of makeLocalNodes) {
    const execConns = connections.filter(c => c.from.nodeId === makeLocalNode.id && c.from.portId === 'output_0');
    for (const conn of execConns) {
      const targetNode = ctx.nodeMap.get(conn.to.nodeId);
      if (!targetNode) continue;
      fileLevelVarNodeIds.add(targetNode.id);
      const decl = generateVarDeclaration(targetNode, false);
      if (decl) output.push(decl);
    }
  }
  
  if (makeGlobalNodes.length > 0 || makeLocalNodes.length > 0) {
    output.push('');
  }
  
  // Store file-level var node IDs in context so inline generation can skip them
  (ctx as any).globalVarNodeIds = fileLevelVarNodeIds;

  if (serverInit) {
    output.push('#if SERVER');
    output.push(`void function ${serverInit.data.functionName || 'CodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(serverInit.id);

    const execConns = getOutputConnections(ctx, serverInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    // Generate thread functions for this context
    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  if (clientInit) {
    output.push('#if CLIENT');
    output.push(`void function ${clientInit.data.functionName || 'ClientCodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(clientInit.id);

    const execConns = getOutputConnections(ctx, clientInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  if (uiInit) {
    output.push('#if UI');
    output.push(`void function ${uiInit.data.functionName || 'UICodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(uiInit.id);

    const execConns = getOutputConnections(ctx, uiInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  // Handle standalone event and custom function nodes
  // For server callback events, always include them (they may have been visited via Register but still need function generated)
  const eventNodes = nodes.filter(n =>
    (n.category === 'callbacks' || n.type === 'custom-function') &&
    (serverCallbackTypes.includes(n.type) || !ctx.visitedNodes.has(n.id))
  );

  // Alias the context detection function for use below
  const getFunctionContext = getFunctionContexts;

  // Helper to get event function parameters and setup variable mappings
  const getEventParams = (eventNode: ScriptNode): { params: string; setupVars: (nodeId: string) => void } => {
    switch (eventNode.type) {
      case 'on-entities-did-load':
        return { params: '', setupVars: () => {} };
      case 'on-client-connected':
      case 'on-client-disconnected':
      case 'on-player-respawned':
        return { 
          params: 'entity player', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
          }
        };
      case 'on-player-killed':
        return { 
          params: 'entity victim, entity attacker, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'victim');
            ctx.variables.set(`${nodeId}:output_3`, 'attacker');
            ctx.variables.set(`${nodeId}:output_4`, 'damageInfo');
          }
        };
      case 'on-weapon-activate':
      case 'on-weapon-deactivate':
      case 'on-weapon-charge-begin':
      case 'on-weapon-charge-end':
      case 'on-weapon-reload':
      case 'on-ability-start':
      case 'on-ability-end':
      case 'on-ability-charge-begin':
      case 'on-ability-execute':
        return { 
          params: 'entity weapon', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'weapon');
          }
        };
      case 'on-weapon-primary-attack':
        return { 
          params: 'entity weapon, WeaponPrimaryAttackParams attackParams', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'weapon');
            ctx.variables.set(`${nodeId}:output_2`, 'attackParams');
          }
        };
      case 'on-projectile-collision':
        return { 
          params: 'entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'projectile');
            ctx.variables.set(`${nodeId}:output_2`, 'pos');
            ctx.variables.set(`${nodeId}:output_3`, 'normal');
            ctx.variables.set(`${nodeId}:output_4`, 'hitEnt');
          }
        };
      case 'on-damage':
        return { 
          params: 'entity ent, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'ent');
            ctx.variables.set(`${nodeId}:output_2`, 'damageInfo');
          }
        };
      case 'on-killed':
        return { 
          params: 'entity ent, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'ent');
            ctx.variables.set(`${nodeId}:output_2`, 'damageInfo');
          }
        };
      // New callback types
      case 'on-npc-killed':
        return { 
          params: 'entity npc, entity attacker, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'npc');
            ctx.variables.set(`${nodeId}:output_3`, 'attacker');
            ctx.variables.set(`${nodeId}:output_4`, 'damageInfo');
          }
        };
      case 'on-client-connecting':
      case 'on-entity-changed-team':
      case 'on-player-inventory-changed':
      case 'on-player-class-changed':
      case 'on-player-changed-team':
      case 'on-player-zoom-in':
      case 'on-player-zoom-out':
      case 'on-passive-changed':
      case 'on-ping-created':
      case 'on-player-match-state-changed':
      case 'on-bleedout-started':
      case 'on-bleedout-ended':
      case 'on-player-scored':
      case 'on-use-button-pressed':
      case 'on-use-button-released':
      case 'on-grappled':
      case 'on-grapple-detached':
        return { 
          params: 'entity player', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
          }
        };
      case 'on-player-assist':
        return { 
          params: 'entity player, entity victim', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
            ctx.variables.set(`${nodeId}:output_3`, 'victim');
          }
        };
      case 'on-weapon-attack':
      case 'on-player-weapon-activated':
      case 'on-player-used-offhand':
        return { 
          params: 'entity weapon, entity player', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'weapon');
            ctx.variables.set(`${nodeId}:output_3`, 'player');
          }
        };
      case 'on-death-box-spawned':
        return { 
          params: 'entity deathBox', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'deathBox');
          }
        };
      case 'on-game-state-enter':
        return { 
          params: 'int gameState', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'gameState');
          }
        };
      case 'on-deathfield-stage-changed':
        return { 
          params: 'int stage', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'stage');
          }
        };
      case 'on-leave-match':
      case 'on-you-respawned':
      case 'on-you-died':
        return { params: '', setupVars: () => {} };
      case 'on-vehicle-launch':
      case 'on-vehicle-collide':
        return { 
          params: 'entity vehicle', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'vehicle');
          }
        };
      case 'on-player-life-state-changed':
        return { 
          params: 'entity player, int oldState, int newState', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
            ctx.variables.set(`${nodeId}:output_3`, 'oldState');
            ctx.variables.set(`${nodeId}:output_4`, 'newState');
          }
        };
      case 'on-lootbin-opened':
        return { 
          params: 'entity player, entity lootbin', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
            ctx.variables.set(`${nodeId}:output_3`, 'lootbin');
          }
        };
      case 'on-player-add-weapon-mod':
      case 'on-player-remove-weapon-mod':
        return { 
          params: 'entity player, entity weapon, string modName', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
            ctx.variables.set(`${nodeId}:output_3`, 'weapon');
            ctx.variables.set(`${nodeId}:output_4`, 'modName');
          }
        };
      case 'custom-function': {
        // Build params from node data
        const paramCount = typeof eventNode.data.paramCount === 'number' ? eventNode.data.paramCount : 0;
        const paramNames = Array.isArray(eventNode.data.paramNames) ? eventNode.data.paramNames : [];
        const paramTypes = Array.isArray(eventNode.data.paramTypes) ? eventNode.data.paramTypes : [];
        const paramList: string[] = [];
        for (let i = 0; i < paramCount; i++) {
          const pName = paramNames[i] || `arg${i + 1}`;
          const pType = paramTypes[i] || 'var';
          paramList.push(`${pType} ${pName}`);
        }
        return { 
          params: paramList.join(', '), 
          setupVars: (nodeId: string) => {
            for (let i = 0; i < paramCount; i++) {
              const pName = paramNames[i] || `arg${i + 1}`;
              ctx.variables.set(`${nodeId}:output_${i + 1}`, pName);
            }
          }
        };
      }
      default:
        return { params: '', setupVars: () => {} };
    }
  };

  for (const eventNode of eventNodes) {
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];

    const eventFuncName = eventNode.data.functionName || `${eventNode.type.replace(/-/g, '_')}_handler`;
    // Use the return type from custom-function nodes, default to void for events
    const returnType = eventNode.type === 'custom-function' && eventNode.data.returnType 
      ? eventNode.data.returnType 
      : 'void';
    
    // Get event-specific parameters
    const { params, setupVars } = getEventParams(eventNode);
    
    // Determine if this function needs context wrapping (returns array of contexts or null)
    const functionContexts = getFunctionContext(eventNode);
    const contextDirective = functionContexts ? formatContextDirective(functionContexts) : null;
    
    // Only init functions get global declarations by default
    // Custom functions only become global if user explicitly uses a "globalize function" node
    // Server callback events (OnClientConnected, OnEntitiesDidLoad, etc.) are internal and don't need global
    const needsGlobalDeclaration = false; // Init functions are handled separately above
    
    // Add global function declaration with context wrapping (only for explicitly globalized functions)
    if (needsGlobalDeclaration) {
      if (contextDirective) {
        output.push(`#if ${contextDirective}`);
      }
      output.push(`global function ${eventFuncName}`);
      if (contextDirective) {
        output.push(`#endif`);
        output.push('');
      }
    }
    
    // Add function definition with context wrapping
    if (contextDirective) {
      output.push(`#if ${contextDirective}`);
    }
    output.push(`${returnType} function ${eventFuncName}(${params})`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.add(eventNode.id);
    
    // Setup variable mappings for event outputs
    setupVars(eventNode.id);

    // For server callback events (with Register input), use output_1 for Exec
    // For other events (custom-function, weapon events, etc.), use output_0
    const execOutputId = ['on-entities-did-load', 'on-client-connected', 'on-client-disconnected', 'on-player-killed', 'on-player-respawned'].includes(eventNode.type) ? 'output_1' : 'output_0';
    const execConns = getOutputConnections(ctx, eventNode.id, execOutputId);
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    // Generate thread functions for this context
    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }
    
    if (contextDirective) {
      output.push(`#endif`);
    }

    output.push('');
    
    }

  return output.join('\n');
}
