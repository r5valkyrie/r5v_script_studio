import type { ScriptNode, NodeConnection } from '../types/visual-scripting';

interface ThreadFunction {
  name: string;
  nodeId: string;
  outputPortId: string;
}

interface CodeGenContext {
  nodes: ScriptNode[];
  connections: NodeConnection[];
  nodeMap: Map<string, ScriptNode>;
  visitedNodes: Set<string>;
  indentLevel: number;
  variables: Map<string, string>;
  varCounter: number;
  threadFunctions: ThreadFunction[];
  pendingLines: string[]; // Lines generated by data nodes that need to be prepended
  portals: Map<string, string>; // Portal name -> variable name
}

function getInputConnections(ctx: CodeGenContext, nodeId: string, portId: string): NodeConnection[] {
  return ctx.connections.filter(c => c.to.nodeId === nodeId && c.to.portId === portId);
}

function getOutputConnections(ctx: CodeGenContext, nodeId: string, portId: string): NodeConnection[] {
  return ctx.connections.filter(c => c.from.nodeId === nodeId && c.from.portId === portId);
}

function indent(ctx: CodeGenContext): string {
  return '    '.repeat(ctx.indentLevel);
}

function getVarName(ctx: CodeGenContext, prefix: string = 'v'): string {
  return `${prefix}${ctx.varCounter++}`;
}

// Map visual scripting dataTypes to Squirrel types
function getSquirrelType(dataType: string | undefined): string {
  switch (dataType) {
    case 'entity':
    case 'player':
    case 'weapon':
      return 'entity';
    case 'boolean':
      return 'bool';
    case 'number':
    case 'int':
      return 'int';
    case 'float':
      return 'float';
    case 'string':
      return 'string';
    case 'vector':
      return 'vector';
    case 'array':
      return 'array';
    case 'table':
      return 'table';
    default:
      return 'var';
  }
}

function formatLiteral(value: unknown): string {
  if (value === null || value === undefined) return 'null';
  if (typeof value === 'string') return `"${value}"`;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  if (Array.isArray(value)) {
    return `[${value.map(formatLiteral).join(', ')}]`;
  }
  return String(value);
}

function getInputValue(ctx: CodeGenContext, node: ScriptNode, portId: string): string {
  const inputConns = getInputConnections(ctx, node.id, portId);

  if (inputConns.length > 0) {
    const conn = inputConns[0];
    const varKey = `${conn.from.nodeId}:${conn.from.portId}`;
    const varVal = ctx.variables.get(varKey);
    if (varVal) return varVal;

    // Try to generate the source node first if it's a data node
    const sourceNode = ctx.nodeMap.get(conn.from.nodeId);
    if (sourceNode && !ctx.visitedNodes.has(sourceNode.id)) {
      const generatedCode = generateNodeCode(ctx, sourceNode);
      // Add the generated code to pending lines so it gets output before the node that uses it
      if (generatedCode && generatedCode.trim()) {
        ctx.pendingLines.push(generatedCode);
      }
      const newVal = ctx.variables.get(varKey);
      if (newVal) return newVal;
    }
    return 'null';
  }

  // Check node data for default value
  const port = node.inputs.find(p => p.id === portId);
  if (port) {
    // Try exact match with data keys
    for (const [key, val] of Object.entries(node.data)) {
      const keyLower = key.toLowerCase();
      const labelLower = port.label.toLowerCase().replace(/\s+/g, '');
      if (keyLower === labelLower || labelLower.includes(keyLower)) {
        if ((port.dataType === 'asset' || port.dataType === 'function') && typeof val === 'string') {
          return val;
        }
        return formatLiteral(val);
      }
    }
  }

  return 'null';
}

function generateNodeCode(ctx: CodeGenContext, node: ScriptNode): string {
  const lines: string[] = [];
  const ind = indent(ctx);

  // Helper to follow exec output
  const followExec = (portId: string) => {
    const conns = getOutputConnections(ctx, node.id, portId);
    for (const conn of conns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) lines.push(code);
    }
  };

  switch (node.type) {
    // ==================== CORE FLOW ====================
    case 'sequence':
    case 'exec-sequence': {
      const execOuts = node.outputs.filter(p => p.type === 'exec');
      for (const out of execOuts) {
        followExec(out.id);
      }
      break;
    }

    case 'branch': {
      const condition = getInputValue(ctx, node, 'input_1');
      // Flush any pending lines before the if statement (e.g., variable declarations from condition evaluation)
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}if (${condition})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // True
      ctx.indentLevel--;
      lines.push(`${ind}}`);

      const falseConns = getOutputConnections(ctx, node.id, 'output_1');
      if (falseConns.length > 0) {
        lines.push(`${ind}else`);
        lines.push(`${ind}{`);
        ctx.indentLevel++;
        followExec('output_1'); // False
        ctx.indentLevel--;
        lines.push(`${ind}}`);
      }
      break;
    }

    case 'delay':
    case 'wait': {
      const duration = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}wait ${duration}`);
      followExec('output_0');
      break;
    }

    case 'loop-for': {
      const start = getInputValue(ctx, node, 'input_1');
      const end = getInputValue(ctx, node, 'input_2');
      const step = getInputValue(ctx, node, 'input_3');
      const indexVar = getVarName(ctx, 'i');
      ctx.variables.set(`${node.id}:output_1`, indexVar);

      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}for (local ${indexVar} = ${start}; ${indexVar} < ${end}; ${indexVar} += ${step})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_2'); // Done
      break;
    }

    case 'loop-foreach': {
      const array = getInputValue(ctx, node, 'input_1');
      const elemVar = getVarName(ctx, 'elem');
      const indexVar = getVarName(ctx, 'idx');
      ctx.variables.set(`${node.id}:output_1`, elemVar);
      ctx.variables.set(`${node.id}:output_2`, indexVar);

      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}foreach (${indexVar}, ${elemVar} in ${array})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_3'); // Done
      break;
    }

    case 'loop-while': {
      const condition = getInputValue(ctx, node, 'input_1');
      // Flush any pending lines before the loop
      if (ctx.pendingLines.length > 0) {
        lines.push(...ctx.pendingLines);
        ctx.pendingLines = [];
      }
      lines.push(`${ind}while (${condition})`);
      lines.push(`${ind}{`);
      ctx.indentLevel++;
      followExec('output_0'); // Loop body
      ctx.indentLevel--;
      lines.push(`${ind}}`);
      followExec('output_1'); // Done
      break;
    }

    case 'thread': {
      // Use custom function name if provided, otherwise generate from node ID
      const customName = typeof node.data.functionName === 'string' && node.data.functionName.trim() 
        ? node.data.functionName.trim().replace(/[^a-zA-Z0-9_]/g, '_')
        : null;
      const funcName = customName || `__Thread_${node.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
      // Register thread function to be generated later
      ctx.threadFunctions.push({
        name: funcName,
        nodeId: node.id,
        outputPortId: 'output_0', // Thread body output
      });
      lines.push(`${ind}thread ${funcName}()`);
      followExec('output_1'); // Continue
      break;
    }

    case 'call-function': {
      const funcName = getInputValue(ctx, node, 'input_1');
      const arg = getInputValue(ctx, node, 'input_2');
      const returnType = typeof node.data?.returnType === 'string' ? node.data.returnType : 'none';
      
      // Build argument string - only include if connected
      const argStr = (arg && arg !== 'null') ? arg : '';
      
      if (returnType !== 'none') {
        const resultVar = getVarName(ctx, 'result');
        ctx.variables.set(`${node.id}:output_1`, resultVar);
        lines.push(`${ind}${returnType} ${resultVar} = ${funcName}(${argStr})`);
      } else {
        lines.push(`${ind}${funcName}(${argStr})`);
      }
      followExec('output_0');
      break;
    }

    // Server callback event nodes - when exec input is connected, generate the AddCallback registration
    case 'on-entities-did-load': {
      const funcName = node.data?.functionName || 'OnEntitiesDidLoad';
      lines.push(`${ind}AddCallback_EntitiesDidLoad( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-client-connected': {
      const funcName = node.data?.functionName || 'OnClientConnected';
      lines.push(`${ind}AddCallback_OnClientConnected( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-client-disconnected': {
      const funcName = node.data?.functionName || 'OnClientDisconnected';
      lines.push(`${ind}AddCallback_OnClientDisconnected( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-player-killed': {
      const funcName = node.data?.functionName || 'OnPlayerKilled';
      lines.push(`${ind}AddCallback_OnPlayerKilled( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'on-player-respawned': {
      const funcName = node.data?.functionName || 'OnPlayerRespawned';
      lines.push(`${ind}AddCallback_OnPlayerRespawned( ${funcName} )`);
      followExec('output_0'); // Next output
      break;
    }

    case 'return': {
      const returnValue = getInputValue(ctx, node, 'input_1');
      if (returnValue && returnValue !== 'null') {
        lines.push(`${ind}return ${returnValue}`);
      } else {
        lines.push(`${ind}return`);
      }
      break;
    }

    case 'reroute-exec': {
      followExec('output_0');
      break;
    }

    case 'set-portal': {
      const portalName = node.data?.portalName || 'MyPortal';
      const value = getInputValue(ctx, node, 'input_1');
      const portalType = node.data?.portalType || 'any';
      const sqType = getSquirrelType(portalType);
      
      // Check if portal variable already exists
      if (!ctx.portals.has(portalName)) {
        const portalVar = getVarName(ctx, 'portal_' + portalName.replace(/[^a-zA-Z0-9]/g, '_'));
        ctx.portals.set(portalName, portalVar);
        lines.push(`${ind}${sqType} ${portalVar} = ${value}`);
      } else {
        const portalVar = ctx.portals.get(portalName)!;
        lines.push(`${ind}${portalVar} = ${value}`);
      }
      followExec('output_0');
      break;
    }

    case 'get-portal': {
      const portalName = node.data?.portalName || 'MyPortal';
      
      if (ctx.portals.has(portalName)) {
        ctx.variables.set(`${node.id}:output_0`, ctx.portals.get(portalName)!);
      } else {
        // Portal not set yet, use null as fallback
        ctx.variables.set(`${node.id}:output_0`, 'null /* Portal "' + portalName + '" not set */');
      }
      break;
    }

    // ==================== GAMEMODES ====================
    case 'gamemode-create': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}GameMode_Create(${gamemode})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-name': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const name = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetName(${gamemode}, ${name})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-desc': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const desc = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetDesc(${gamemode}, ${desc})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-score-limits': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const scoreLimit = getInputValue(ctx, node, 'input_2');
      const roundScoreLimit = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}GameMode_SetDefaultScoreLimits(${gamemode}, ${scoreLimit}, ${roundScoreLimit})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-time-limits': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const timeLimit = getInputValue(ctx, node, 'input_2');
      const roundTimeLimit = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}GameMode_SetDefaultTimeLimits(${gamemode}, ${timeLimit}, ${roundTimeLimit})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-scoreboard-column': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const title = getInputValue(ctx, node, 'input_2');
      const scoreType = getInputValue(ctx, node, 'input_3');
      const numDigits = getInputValue(ctx, node, 'input_4');
      lines.push(`${ind}GameMode_AddScoreboardColumnData(${gamemode}, ${title}, ${scoreType}, ${numDigits})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-shared-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddSharedInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-server-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddServerInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-add-client-init': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_AddClientInit(${gamemode}, ${func})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-set-evac': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const enabled = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}GameMode_SetEvacEnabled(${gamemode}, ${enabled})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-register-spawn-func': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const func = getInputValue(ctx, node, 'input_2');
      const isPilot = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}RegisterGamemodeSpawnFunc(${gamemode}, ${func}, ${isPilot})`);
      followExec('output_0');
      break;
    }

    case 'gamemode-register': {
      const gamemode = getInputValue(ctx, node, 'input_1');
      const modName = getInputValue(ctx, node, 'input_2');
      const displayName = getInputValue(ctx, node, 'input_3');
      const description = getInputValue(ctx, node, 'input_4');
      const customScoreboard = getInputValue(ctx, node, 'input_5');
      const sharedInitFn = getInputValue(ctx, node, 'input_6');
      const serverInitFn = getInputValue(ctx, node, 'input_7');
      const clientInitFn = getInputValue(ctx, node, 'input_8');
      lines.push(`${ind}RegisterGamemode(${gamemode}, ${modName}, ${displayName}, ${description}, ${customScoreboard}, ${sharedInitFn}, ${serverInitFn}, ${clientInitFn})`);
      followExec('output_0');
      break;
    }

    // ==================== DAMAGE ====================
    case 'entity-take-damage': {
      const entity = getInputValue(ctx, node, 'input_1');
      const attacker = getInputValue(ctx, node, 'input_2');
      const inflictor = getInputValue(ctx, node, 'input_3');
      const damage = getInputValue(ctx, node, 'input_4');
      const damageType = getInputValue(ctx, node, 'input_5');
      lines.push(`${ind}${entity}.TakeDamage(${damage}, ${attacker}, ${inflictor}, { damageType = ${damageType} })`);
      followExec('output_0');
      break;
    }

    case 'radius-damage': {
      const origin = getInputValue(ctx, node, 'input_1');
      const attacker = getInputValue(ctx, node, 'input_2');
      const inflictor = getInputValue(ctx, node, 'input_3');
      const damage = getInputValue(ctx, node, 'input_4');
      const radius = getInputValue(ctx, node, 'input_5');
      lines.push(`${ind}RadiusDamage(${origin}, ${attacker}, ${inflictor}, ${damage}, ${radius})`);
      followExec('output_0');
      break;
    }

    // ==================== ENTITY ====================
    case 'get-origin': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'origin');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetOrigin()`);
      break;
    }

    case 'set-origin': {
      const entity = getInputValue(ctx, node, 'input_1');
      const origin = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetOrigin(${origin})`);
      followExec('output_0');
      break;
    }

    case 'get-velocity': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'velocity');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetVelocity()`);
      break;
    }

    case 'set-velocity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const velocity = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetVelocity(${velocity})`);
      followExec('output_0');
      break;
    }

    case 'get-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'health');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetHealth()`);
      break;
    }

    case 'get-max-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'maxHealth');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetMaxHealth()`);
      break;
    }

    case 'get-shield-health': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'shield');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetShieldHealth()`);
      break;
    }

    case 'get-team': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'team');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetTeam()`);
      break;
    }

    case 'get-player-name': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'playerName');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${player}.GetPlayerName()`);
      break;
    }

    case 'get-owner': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'owner');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${entity}.GetOwner()`);
      break;
    }

    case 'get-parent': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'parent');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${entity}.GetParent()`);
      break;
    }

    case 'get-class-name': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'className');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${entity}.GetClassName()`);
      break;
    }

    case 'get-ent-index': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'entIndex');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${entity}.GetEntIndex()`);
      break;
    }

    case 'get-script-name': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'scriptName');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${entity}.GetScriptName()`);
      break;
    }

    case 'get-view-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'viewVec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetViewVector()`);
      break;
    }

    case 'get-angles': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'angles');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetAngles()`);
      break;
    }

    case 'get-forward-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'forward');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetForwardVector()`);
      break;
    }

    case 'get-right-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'right');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetRightVector()`);
      break;
    }

    case 'get-up-vector': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'up');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.GetUpVector()`);
      break;
    }

    case 'get-eye-position': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'eyePos');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.EyePosition()`);
      break;
    }

    case 'get-eye-angles': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'eyeAngles');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${entity}.EyeAngles()`);
      break;
    }

    case 'get-weapon-class-name': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'weaponClass');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${weapon}.GetWeaponClassName()`);
      break;
    }

    case 'set-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const health = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetHealth(${health})`);
      followExec('output_0');
      break;
    }

    case 'set-max-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const maxHealth = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetMaxHealth(${maxHealth})`);
      followExec('output_0');
      break;
    }

    case 'set-shield-health': {
      const entity = getInputValue(ctx, node, 'input_1');
      const shield = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetShieldHealth(${shield})`);
      followExec('output_0');
      break;
    }

    case 'set-team': {
      const entity = getInputValue(ctx, node, 'input_1');
      const team = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}SetTeam(${entity}, ${team})`);
      followExec('output_0');
      break;
    }

    case 'set-owner': {
      const entity = getInputValue(ctx, node, 'input_1');
      const owner = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetOwner(${owner})`);
      followExec('output_0');
      break;
    }

    case 'set-parent': {
      const entity = getInputValue(ctx, node, 'input_1');
      const parent = getInputValue(ctx, node, 'input_2');
      const attachment = getInputValue(ctx, node, 'input_3');
      if (attachment && attachment !== '""' && attachment !== 'null') {
        lines.push(`${ind}${entity}.SetParent(${parent}, ${attachment})`);
      } else {
        lines.push(`${ind}${entity}.SetParent(${parent})`);
      }
      followExec('output_0');
      break;
    }

    case 'clear-parent': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.ClearParent()`);
      followExec('output_0');
      break;
    }

    case 'set-angles': {
      const entity = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetAngles(${angles})`);
      followExec('output_0');
      break;
    }

    case 'set-script-name': {
      const entity = getInputValue(ctx, node, 'input_1');
      const scriptName = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${entity}.SetScriptName(${scriptName})`);
      followExec('output_0');
      break;
    }

    case 'is-valid': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isValid');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsValid(${entity})`);
      break;
    }

    case 'is-alive': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isAlive');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsAlive(${entity})`);
      break;
    }

    case 'is-player': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isPlayer');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsPlayer()`);
      break;
    }

    case 'is-npc': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isNPC');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsNPC()`);
      break;
    }

    case 'is-titan': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isTitan');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = ${entity}.IsTitan()`);
      break;
    }

    case 'is-pilot': {
      const entity = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'isPilot');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}bool ${resultVar} = IsPilot(${entity})`);
      break;
    }

    case 'kill-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${entity}.Kill()`);
      followExec('output_0');
      break;
    }

    case 'get-weapon-owner': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'owner');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${weapon}.GetWeaponOwner()`);
      break;
    }

    case 'register-mod-weapon': {
      const className = getInputValue(ctx, node, 'input_1');
      const name = getInputValue(ctx, node, 'input_2');
      const hudIcon = getInputValue(ctx, node, 'input_3');
      const weaponType = getInputValue(ctx, node, 'input_4');
      const pickupSound1p = getInputValue(ctx, node, 'input_5');
      const pickupSound3p = getInputValue(ctx, node, 'input_6');
      const tier = getInputValue(ctx, node, 'input_7');
      const baseMods = getInputValue(ctx, node, 'input_8');
      const supportedAttachments = getInputValue(ctx, node, 'input_9');
      const lowWeaponChance = getInputValue(ctx, node, 'input_10');
      const medWeaponChance = getInputValue(ctx, node, 'input_11');
      const highWeaponChance = getInputValue(ctx, node, 'input_12');
      const registerInLoot = getInputValue(ctx, node, 'input_13');

      const dataVar = getVarName(ctx, 'weaponData');
      lines.push(`${ind}CustomWeaponData ${dataVar}`);
      lines.push(`${ind}${dataVar}.className = ${className}`);
      lines.push(`${ind}${dataVar}.name = ${name}`);
      lines.push(`${ind}${dataVar}.hudIcon = ${hudIcon}`);
      lines.push(`${ind}${dataVar}.weaponType = ${weaponType}`);
      lines.push(`${ind}${dataVar}.pickupSound1p = ${pickupSound1p}`);
      lines.push(`${ind}${dataVar}.pickupSound3p = ${pickupSound3p}`);
      lines.push(`${ind}${dataVar}.tier = ${tier}`);
      lines.push(`${ind}${dataVar}.baseMods = ${baseMods}`);
      lines.push(`${ind}${dataVar}.supportedAttachments = ${supportedAttachments}`);
      lines.push(`${ind}${dataVar}.lowWeaponChance = ${lowWeaponChance}`);
      lines.push(`${ind}${dataVar}.medWeaponChance = ${medWeaponChance}`);
      lines.push(`${ind}${dataVar}.highWeaponChance = ${highWeaponChance}`);
      lines.push(`${ind}RegisterModWeapon(${dataVar}, ${registerInLoot})`);
      followExec('output_0');
      break;
    }

    // ==================== WEAPONS ====================
    case 'get-active-weapon': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${player}.GetActiveWeapon()`);
      break;
    }

    case 'give-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weaponClass = getInputValue(ctx, node, 'input_2');
      const mods = getInputValue(ctx, node, 'input_3');
      const slot = node.data?.slot || 'WEAPON_INVENTORY_SLOT_PRIMARY_0';
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      if (mods && mods !== 'null' && mods !== '[]') {
        lines.push(`${ind}entity ${resultVar} = ${player}.GiveWeapon(${weaponClass}, ${slot}, ${mods})`);
      } else {
        lines.push(`${ind}entity ${resultVar} = ${player}.GiveWeapon(${weaponClass}, ${slot}, [])`);
      }
      followExec('output_0');
      break;
    }

    case 'take-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weaponClass = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${player}.TakeWeapon(${weaponClass})`);
      followExec('output_0');
      break;
    }

    case 'take-all-weapons': {
      const player = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${player}.TakeAllWeapons()`);
      followExec('output_0');
      break;
    }

    case 'switch-to-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      const weapon = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${player}.SetActiveWeapon(${weapon})`);
      followExec('output_0');
      break;
    }

    case 'fire-weapon-bullet': {
      const weapon = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${weapon}.FireWeaponBullet()`);
      followExec('output_0');
      break;
    }

    // ==================== AUDIO ====================
    case 'emit-sound-on-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const sound = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}EmitSoundOnEntity(${entity}, ${sound})`);
      followExec('output_0');
      break;
    }

    // ==================== PARTICLES ====================
    case 'start-particle-on-entity': {
      const entity = getInputValue(ctx, node, 'input_1');
      const effect = getInputValue(ctx, node, 'input_2');
      const attachment = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'fxHandle');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}int ${resultVar} = StartParticleEffectOnEntity(${entity}, GetParticleSystemIndex(${effect}), FX_PATTACH_POINT_FOLLOW, ${attachment})`);
      followExec('output_0');
      break;
    }

    // ==================== STRING ====================
    case 'string-concat': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'string-format': {
      const formatStr = getInputValue(ctx, node, 'input_0');
      const arg1 = getInputValue(ctx, node, 'input_1');
      const arg2 = getInputValue(ctx, node, 'input_2');
      const arg3 = getInputValue(ctx, node, 'input_3');
      const arg4 = getInputValue(ctx, node, 'input_4');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      
      // Build args list, only include non-null args
      const args = [arg1, arg2, arg3, arg4].filter(a => a && a !== 'null');
      if (args.length > 0) {
        lines.push(`${ind}string ${resultVar} = format(${formatStr}, ${args.join(', ')})`);
      } else {
        lines.push(`${ind}string ${resultVar} = ${formatStr}`);
      }
      break;
    }

    case 'to-string': {
      const value = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = string(${value})`);
      break;
    }

    case 'get-player-name': {
      const player = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'name');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = ${player}.GetPlayerName()`);
      break;
    }

    case 'string-builder': {
      const inputCount = typeof node.data?.inputCount === 'number' ? node.data.inputCount : node.inputs.length;
      const parts: string[] = [];
      for (let i = 0; i < inputCount; i++) {
        const part = getInputValue(ctx, node, `input_${i}`);
        if (part && part !== 'null') {
          parts.push(part);
        }
      }
      const resultVar = getVarName(ctx, 'str');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      if (parts.length === 0) {
        lines.push(`${ind}string ${resultVar} = ""`);
      } else if (parts.length === 1) {
        lines.push(`${ind}string ${resultVar} = string(${parts[0]})`);
      } else {
        // Wrap each part in string() and concatenate
        const stringParts = parts.map(p => `${p}`);
        lines.push(`${ind}string ${resultVar} = ${stringParts.join(' + ')}`);
      }
      break;
    }

    // ==================== MATH ====================
    case 'vector-create': {
      const x = getInputValue(ctx, node, 'input_0');
      const y = getInputValue(ctx, node, 'input_1');
      const z = getInputValue(ctx, node, 'input_2');
      const resultVar = getVarName(ctx, 'vec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = <${x}, ${y}, ${z}>`);
      break;
    }

    case 'vector-add': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'vec');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'vector-normalize': {
      const v = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'normalized');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}vector ${resultVar} = Normalize(${v})`);
      break;
    }

    case 'math-add': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${a} + ${b}`);
      break;
    }

    case 'math-multiply': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'result');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${a} * ${b}`);
      break;
    }

    case 'math-random-float': {
      const min = getInputValue(ctx, node, 'input_0');
      const max = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'rand');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}float ${resultVar} = RandomFloatRange(${min}, ${max})`);
      break;
    }

    // ==================== DATA ====================
    case 'const-string': {
      const value = node.data.value || '';
      ctx.variables.set(`${node.id}:output_0`, `"${value}"`);
      break;
    }

    case 'function-ref': {
      const value = node.data.functionName || 'MyFunction';
      ctx.variables.set(`${node.id}:output_0`, value);
      break;
    }

    case 'const-asset': {
      const value = node.data.value || '$""';
      ctx.variables.set(`${node.id}:output_0`, value);
      break;
    }

    case 'const-loot-tier': {
      const tier = node.data.tier || 'COMMON';
      ctx.variables.set(`${node.id}:output_0`, `eLootTier.${tier}`);
      break;
    }

    case 'const-supported-attachments': {
      const attachments = Array.isArray(node.data.attachments) ? node.data.attachments : [];
      ctx.variables.set(`${node.id}:output_0`, formatLiteral(attachments));
      break;
    }

    case 'const-weapon-type': {
      const weaponType = node.data.weaponType || 'pistol';
      ctx.variables.set(`${node.id}:output_0`, `"${weaponType}"`);
      break;
    }

    case 'const-float':
    case 'const-int': {
      const value = node.data.value ?? 0;
      ctx.variables.set(`${node.id}:output_0`, String(value));
      break;
    }

    case 'const-bool': {
      const value = node.data.value ?? false;
      ctx.variables.set(`${node.id}:output_0`, value ? 'true' : 'false');
      break;
    }

    case 'const-vector': {
      const x = node.data.x ?? 0;
      const y = node.data.y ?? 0;
      const z = node.data.z ?? 0;
      ctx.variables.set(`${node.id}:output_0`, `<${x}, ${y}, ${z}>`);
      break;
    }

    case 'reroute': {
      const inputValue = getInputValue(ctx, node, 'input_0');
      ctx.variables.set(`${node.id}:output_0`, inputValue);
      break;
    }

    case 'array-create': {
      const resultVar = getVarName(ctx, 'arr');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array ${resultVar} = []`);
      break;
    }

    case 'array-append': {
      const array = getInputValue(ctx, node, 'input_1');
      const element = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${array}.append(${element})`);
      ctx.variables.set(`${node.id}:output_1`, array);
      followExec('output_0');
      break;
    }

    case 'array-get': {
      const array = getInputValue(ctx, node, 'input_0');
      const index = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'elem');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}var ${resultVar} = ${array}[${index}]`);
      break;
    }

    case 'array-length': {
      const array = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'len');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${array}.len()`);
      break;
    }

    // ==================== UTILITIES ====================
    case 'print': {
      const partCount = typeof node.data?.partCount === 'number' ? node.data.partCount : (node.inputs.length - 1);
      const parts: string[] = [];
      for (let i = 0; i < partCount; i++) {
        const part = getInputValue(ctx, node, `input_${i + 1}`);
        if (part && part !== 'null') {
          parts.push(part);
        }
      }
      if (parts.length === 0) {
        lines.push(`${ind}printf("")`);
      } else {
        // Auto-generate format string with %s for each part
        const formatStr = parts.map(() => '%s').join('');
        lines.push(`${ind}printf("${formatStr}", ${parts.join(', ')})`);
      }
      followExec('output_0');
      break;
    }

    case 'get-all-players': {
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetPlayerArray()`);
      break;
    }

    case 'get-players-on-team': {
      const team = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetPlayerArrayOfTeam(${team})`);
      break;
    }

    case 'get-living-players': {
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetLivingPlayers()`);
      break;
    }

    case 'get-living-players-on-team': {
      const team = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'players');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}array<entity> ${resultVar} = GetLivingPlayersOnTeam(${team})`);
      break;
    }

    case 'get-local-player': {
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetLocalClientPlayer()`);
      break;
    }

    case 'get-local-view-player': {
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetLocalViewPlayer()`);
      break;
    }

    case 'get-ent-by-index': {
      const index = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'ent');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = GetEntByIndex(${index})`);
      break;
    }

    case 'get-player-by-index': {
      const index = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'player');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = gp()[${index}]`);
      break;
    }

    case 'get-offhand-weapon': {
      const player = getInputValue(ctx, node, 'input_0');
      const slot = getInputValue(ctx, node, 'input_1');
      const resultVar = getVarName(ctx, 'weapon');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}entity ${resultVar} = ${player}.GetOffhandWeapon(${slot})`);
      break;
    }

    case 'get-weapon-primary-clip-count': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'clipCount');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${weapon}.GetWeaponPrimaryClipCount()`);
      break;
    }

    case 'get-weapon-ammo-pool-type': {
      const weapon = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'poolType');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}int ${resultVar} = ${weapon}.GetWeaponAmmoPoolType()`);
      break;
    }

    case 'ammo-type-get-ref-from-index': {
      const poolType = getInputValue(ctx, node, 'input_0');
      const resultVar = getVarName(ctx, 'ammoType');
      ctx.variables.set(`${node.id}:output_0`, resultVar);
      lines.push(`${ind}string ${resultVar} = AmmoType_GetRefFromIndex(${poolType})`);
      break;
    }

    case 'create-trigger-cylinder': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const radius = getInputValue(ctx, node, 'input_3');
      const aboveHeight = getInputValue(ctx, node, 'input_4');
      const belowHeight = getInputValue(ctx, node, 'input_5');
      const resultVar = getVarName(ctx, 'trigger');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("trigger_cylinder")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      lines.push(`${ind}${resultVar}.SetAboveHeight(${aboveHeight})`);
      lines.push(`${ind}${resultVar}.SetBelowHeight(${belowHeight})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'create-trigger-radius-multiple': {
      const origin = getInputValue(ctx, node, 'input_1');
      const angles = getInputValue(ctx, node, 'input_2');
      const radius = getInputValue(ctx, node, 'input_3');
      const resultVar = getVarName(ctx, 'trigger');
      ctx.variables.set(`${node.id}:output_1`, resultVar);
      lines.push(`${ind}entity ${resultVar} = CreateEntity("trigger_radius_multiple")`);
      lines.push(`${ind}${resultVar}.SetOrigin(${origin})`);
      lines.push(`${ind}${resultVar}.SetAngles(${angles})`);
      lines.push(`${ind}${resultVar}.SetRadius(${radius})`);
      lines.push(`${ind}DispatchSpawn(${resultVar})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-enabled': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const enabled = getInputValue(ctx, node, 'input_2');
      if (enabled === 'true') {
        lines.push(`${ind}${trigger}.Enable()`);
      } else {
        lines.push(`${ind}${trigger}.Disable()`);
      }
      followExec('output_0');
      break;
    }

    case 'trigger-set-radius': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const radius = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetRadius(${radius})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-above-height': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const height = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetAboveHeight(${height})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-below-height': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const height = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetBelowHeight(${height})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-enter-callback': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const callback = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetEnterCallback(${callback})`);
      followExec('output_0');
      break;
    }

    case 'trigger-set-leave-callback': {
      const trigger = getInputValue(ctx, node, 'input_1');
      const callback = getInputValue(ctx, node, 'input_2');
      lines.push(`${ind}${trigger}.SetLeaveCallback(${callback})`);
      followExec('output_0');
      break;
    }

    case 'trigger-search-new-touching': {
      const trigger = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}${trigger}.SearchForNewTouchingEntity()`);
      followExec('output_0');
      break;
    }

    case 'dispatch-spawn': {
      const entity = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}DispatchSpawn(${entity})`);
      followExec('output_0');
      break;
    }

    case 'take-primary-weapon': {
      const player = getInputValue(ctx, node, 'input_1');
      lines.push(`${ind}TakePrimaryWeapon(${player})`);
      followExec('output_0');
      break;
    }

    case 'set-active-weapon-by-name': {
      const player = getInputValue(ctx, node, 'input_1');
      const slot = getInputValue(ctx, node, 'input_2');
      const weaponName = getInputValue(ctx, node, 'input_3');
      lines.push(`${ind}${player}.SetActiveWeaponByName(${slot}, ${weaponName})`);
      followExec('output_0');
      break;
    }

    // ==================== COMPARISONS ====================
    case 'compare-equal': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `(${a} == ${b})`);
      break;
    }

    case 'compare-greater': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `(${a} > ${b})`);
      break;
    }

    case 'compare-less': {
      const a = getInputValue(ctx, node, 'input_0');
      const b = getInputValue(ctx, node, 'input_1');
      ctx.variables.set(`${node.id}:output_0`, `(${a} < ${b})`);
      break;
    }

    default: {
      lines.push(`${ind}// TODO: ${node.type} - ${node.label}`);
      const execOuts = node.outputs.filter(p => p.type === 'exec');
      if (execOuts.length > 0) {
        followExec(execOuts[0].id);
      }
    }
  }

  // Prepend any pending lines (from data nodes that were generated to resolve inputs)
  const pendingCode = ctx.pendingLines.join('\n');
  ctx.pendingLines = []; // Clear pending lines after using
  
  const nodeCode = lines.filter(l => l.trim()).join('\n');
  if (pendingCode && nodeCode) {
    return pendingCode + '\n' + nodeCode;
  }
  return pendingCode || nodeCode;
}

function generateFromNode(ctx: CodeGenContext, nodeId: string): string {
  if (ctx.visitedNodes.has(nodeId)) return '';

  const node = ctx.nodeMap.get(nodeId);
  if (!node) return '';

  ctx.visitedNodes.add(nodeId);
  return generateNodeCode(ctx, node);
}

// Generate thread function body
function generateThreadFunction(ctx: CodeGenContext, threadFunc: ThreadFunction): string {
  const lines: string[] = [];

  lines.push(`void function ${threadFunc.name}()`);
  lines.push('{');

  ctx.indentLevel = 1;

  // Generate the thread body from the output port
  const bodyConns = getOutputConnections(ctx, threadFunc.nodeId, threadFunc.outputPortId);
  for (const conn of bodyConns) {
    // Don't skip visited - we need to regenerate for thread context
    const node = ctx.nodeMap.get(conn.to.nodeId);
    if (node) {
      const code = generateNodeCode(ctx, node);
      if (code) lines.push(code);
    }
  }

  lines.push('}');
  return lines.join('\n');
}

export function generateCode(nodes: ScriptNode[], connections: NodeConnection[]): string {
  if (nodes.length === 0) {
    return '// No nodes in the visual script\n// Add nodes from the palette to get started';
  }

  const ctx: CodeGenContext = {
    nodes,
    connections,
    nodeMap: new Map(nodes.map(n => [n.id, n])),
    visitedNodes: new Set(),
    indentLevel: 0,
    variables: new Map(),
    varCounter: 0,
    threadFunctions: [],
    pendingLines: [],
    portals: new Map(),
  };

  const output: string[] = [];

  output.push('// Generated by R5V Mod Studio Visual Scripting');
  output.push('// https://github.com/r5valkyrie/r5v_mod_studio');
  output.push('');
  const serverInit = nodes.find(n => n.type === 'init-server');
  const clientInit = nodes.find(n => n.type === 'init-client');
  const uiInit = nodes.find(n => n.type === 'init-ui');

  if (serverInit) {
    output.push('#if SERVER');
    output.push(`global function ${serverInit.data.functionName || 'CodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }
  if (clientInit) {
    output.push('#if CLIENT');
    output.push(`global function ${clientInit.data.functionName || 'ClientCodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }
  if (uiInit) {
    output.push('#if UI');
    output.push(`global function ${uiInit.data.functionName || 'UICodeCallback_ModInit'}`);
    output.push('#endif');
    output.push('');
  }

  if (serverInit) {
    output.push('#if SERVER');
    output.push(`void function ${serverInit.data.functionName || 'CodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(serverInit.id);

    const execConns = getOutputConnections(ctx, serverInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    // Generate thread functions for this context
    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  if (clientInit) {
    output.push('#if CLIENT');
    output.push(`void function ${clientInit.data.functionName || 'ClientCodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(clientInit.id);

    const execConns = getOutputConnections(ctx, clientInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  if (uiInit) {
    output.push('#if UI');
    output.push(`void function ${uiInit.data.functionName || 'UICodeCallback_ModInit'}()`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];
    ctx.visitedNodes.add(uiInit.id);

    const execConns = getOutputConnections(ctx, uiInit.id, 'output_0');
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('#endif');
    output.push('');
  }

  // Server callback event types that have Register input
  const serverCallbackTypes = ['on-entities-did-load', 'on-client-connected', 'on-client-disconnected', 'on-player-killed', 'on-player-respawned'];

  // Handle standalone event and custom function nodes
  // For server callback events, always include them (they may have been visited via Register but still need function generated)
  const eventNodes = nodes.filter(n =>
    (n.category === 'events' || n.type === 'custom-function') &&
    (serverCallbackTypes.includes(n.type) || !ctx.visitedNodes.has(n.id))
  );

  // Helper to get event function parameters and setup variable mappings
  const getEventParams = (eventType: string): { params: string; setupVars: (nodeId: string) => void } => {
    switch (eventType) {
      case 'on-entities-did-load':
        return { params: '', setupVars: () => {} };
      case 'on-client-connected':
      case 'on-client-disconnected':
      case 'on-player-respawned':
        return { 
          params: 'entity player', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'player');
          }
        };
      case 'on-player-killed':
        return { 
          params: 'entity victim, entity attacker, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_2`, 'victim');
            ctx.variables.set(`${nodeId}:output_3`, 'attacker');
            ctx.variables.set(`${nodeId}:output_4`, 'damageInfo');
          }
        };
      case 'on-weapon-activate':
      case 'on-weapon-deactivate':
      case 'on-weapon-charge-begin':
      case 'on-weapon-charge-end':
      case 'on-weapon-reload':
      case 'on-ability-start':
      case 'on-ability-end':
      case 'on-ability-charge-begin':
      case 'on-ability-execute':
        return { 
          params: 'entity weapon', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'weapon');
          }
        };
      case 'on-weapon-primary-attack':
        return { 
          params: 'entity weapon, WeaponPrimaryAttackParams attackParams', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'weapon');
            ctx.variables.set(`${nodeId}:output_2`, 'attackParams');
          }
        };
      case 'on-projectile-collide':
        return { 
          params: 'entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'projectile');
            ctx.variables.set(`${nodeId}:output_2`, 'pos');
            ctx.variables.set(`${nodeId}:output_3`, 'normal');
            ctx.variables.set(`${nodeId}:output_4`, 'hitEnt');
          }
        };
      case 'on-damage':
        return { 
          params: 'entity ent, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'ent');
            ctx.variables.set(`${nodeId}:output_2`, 'damageInfo');
          }
        };
      case 'on-killed':
        return { 
          params: 'entity ent, var damageInfo', 
          setupVars: (nodeId: string) => {
            ctx.variables.set(`${nodeId}:output_1`, 'ent');
            ctx.variables.set(`${nodeId}:output_2`, 'damageInfo');
          }
        };
      default:
        return { params: '', setupVars: () => {} };
    }
  };

  for (const eventNode of eventNodes) {
    ctx.visitedNodes.clear();
    ctx.variables.clear();
    ctx.varCounter = 0;
    ctx.threadFunctions = [];
    ctx.pendingLines = [];

    const eventFuncName = eventNode.data.functionName || `${eventNode.type.replace(/-/g, '_')}_handler`;
    // Use the return type from custom-function nodes, default to void for events
    const returnType = eventNode.type === 'custom-function' && eventNode.data.returnType 
      ? eventNode.data.returnType 
      : 'void';
    
    // Get event-specific parameters
    const { params, setupVars } = getEventParams(eventNode.type);
    
    output.push(`${returnType} function ${eventFuncName}(${params})`);
    output.push('{');
    ctx.indentLevel = 1;
    ctx.visitedNodes.add(eventNode.id);
    
    // Setup variable mappings for event outputs
    setupVars(eventNode.id);

    // For server callback events (with Register input), use output_1 for Exec
    // For other events (custom-function, weapon events, etc.), use output_0
    const execOutputId = ['on-entities-did-load', 'on-client-connected', 'on-client-disconnected', 'on-player-killed', 'on-player-respawned'].includes(eventNode.type) ? 'output_1' : 'output_0';
    const execConns = getOutputConnections(ctx, eventNode.id, execOutputId);
    for (const conn of execConns) {
      const code = generateFromNode(ctx, conn.to.nodeId);
      if (code) output.push(code);
    }

    output.push('}');

    for (const threadFunc of ctx.threadFunctions) {
      output.push('');
      output.push(generateThreadFunction(ctx, threadFunc));
    }

    output.push('');
    
    }

  return output.join('\n');
}
